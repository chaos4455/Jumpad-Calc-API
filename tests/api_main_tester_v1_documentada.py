# -*- coding: utf-8 -*-
"""
Su√≠te de Testes Automatizados para API Matem√°tica Segura (Testes de Integra√ß√£o)

Este script Python implementa uma su√≠te de testes automatizados para verificar a
funcionalidade e robustez da API Matem√°tica Segura, utilizando a biblioteca `unittest`.
Os testes cobrem diversos cen√°rios, incluindo opera√ß√µes de soma e m√©dia, valida√ß√£o de
entrada de dados, endpoints protegidos por autentica√ß√£o JWT, e o endpoint p√∫blico de sa√∫de.

A su√≠te de testes inclui:

    - Testes de endpoints p√∫blicos e protegidos (requer token JWT de administrador).
    - Valida√ß√£o de respostas da API (status code, corpo da resposta em JSON).
    - Testes de casos de sucesso e de falha (erros de valida√ß√£o, erros de tipo, etc.).
    - Gera√ß√£o de logs detalhados em formato JSON para cada execu√ß√£o de teste.
    - Sa√≠da colorida no console para facilitar a leitura dos resultados dos testes.

Configura√ß√£o:
    - A URL base da API e a verifica√ß√£o de certificado SSL podem ser configuradas atrav√©s
      de vari√°veis de ambiente `API_TEST_URL` e `API_VERIFY_SSL`, respectivamente.
    - As credenciais padr√£o 'admin/admin' s√£o utilizadas para obter o token JWT de administrador.

Para executar os testes, basta executar este script Python diretamente. Os resultados
ser√£o exibidos no console e um arquivo de log detalhado em JSON ser√° gerado no diret√≥rio `test_logs`.

Bibliotecas Utilizadas:
    - requests: Para fazer requisi√ß√µes HTTP para a API.
    - json: Para manipula√ß√£o de dados JSON.
    - os: Para manipula√ß√£o de arquivos e vari√°veis de ambiente.
    - unittest: Framework de testes unit√°rios do Python.
    - time: Para medi√ß√£o de tempo de execu√ß√£o dos testes.
    - datetime: Para gera√ß√£o de timestamps nos logs.
    - colorama: Para adicionar cores e estilos √† sa√≠da do console, facilitando a leitura.

Diret√≥rios e Arquivos Gerados:
    - test_logs/: Diret√≥rio para armazenar os arquivos de log dos testes.
        - api-test-log.json: Arquivo de log principal em formato JSON, contendo detalhes de cada execu√ß√£o de teste.

Execu√ß√£o:
    Execute este script diretamente para iniciar a su√≠te de testes. Os resultados e logs
    ser√£o gerados automaticamente.

Criado por: Elias Andrade
Data de Cria√ß√£o: 10 de Mar√ßo de 2025
"""
import requests # üöÄ Biblioteca para fazer requisi√ß√µes HTTP
import json # üóÑÔ∏è Biblioteca para trabalhar com JSON
import os # üìÅ Biblioteca para interagir com o sistema operacional (e.g., vari√°veis de ambiente, caminhos de arquivos)
import unittest # üß™ Framework de testes unit√°rios do Python
import time # ‚è±Ô∏è Biblioteca para fun√ß√µes relacionadas a tempo
from datetime import datetime # üìÖ Biblioteca para trabalhar com datas e horas
import colorama # üé® Biblioteca para adicionar cores e estilos ao texto no terminal
from colorama import Fore, Back, Style # üé® Importa estilos e cores espec√≠ficos do colorama

colorama.init(autoreset=True) # üé® Inicializa o Colorama para que as cores sejam resetadas automaticamente ap√≥s cada print

API_BASE_URL = os.environ.get("API_TEST_URL", "https://localhost:8882") # üåê URL base da API para testes, configur√°vel via vari√°vel de ambiente API_TEST_URL
VERIFY_SSL_CERT = os.environ.get("API_VERIFY_SSL", False) == 'True' # üîí Define se a verifica√ß√£o do certificado SSL est√° habilitada, configur√°vel via API_VERIFY_SSL
LOG_DIR = "test_logs" # üóÇÔ∏è Diret√≥rio para salvar os arquivos de log dos testes
LOG_FILE = os.path.join(LOG_DIR, "api-test-log.json") # üìù Caminho completo para o arquivo de log JSON

ADMIN_TOKEN = None # üîë Vari√°vel global para armazenar o token JWT de administrador, inicialmente None

def obter_token_admin():
    """
    Obt√©m um token JWT de administrador da API para autentica√ß√£o em endpoints protegidos.

    Utiliza as credenciais padr√£o 'admin/admin' para solicitar o token no endpoint '/token_admin' da API.
    Se a requisi√ß√£o for bem-sucedida, armazena o token na vari√°vel global ADMIN_TOKEN e o retorna.
    Em caso de falha na requisi√ß√£o ou erro HTTP, imprime uma mensagem de erro colorida no console e retorna None.

    Returns:
        str | None: O token JWT de administrador (string) se obtido com sucesso, ou None em caso de falha.
    """
    global ADMIN_TOKEN # üîë Indica que a vari√°vel global ADMIN_TOKEN ser√° modificada nesta fun√ß√£o
    token_url = f"{API_BASE_URL}/token_admin" # üîó URL completa para o endpoint de gera√ß√£o de token de admin
    credenciais = {"username": "admin", "password": "admin"} # üë§ Credenciais padr√£o para o usu√°rio administrador
    try:
        resposta = requests.post(token_url, json=credenciais, verify=VERIFY_SSL_CERT) # üìß Faz a requisi√ß√£o POST para obter o token, enviando as credenciais em JSON
        resposta.raise_for_status() # üö® Levanta uma exce√ß√£o para status codes de erro (e.g., 4xx, 5xx)
        ADMIN_TOKEN = resposta.json().get("access_token") # üîë Extrai o token de acesso do JSON da resposta e armazena na vari√°vel global
        return ADMIN_TOKEN # üîë Retorna o token JWT obtido
    except requests.exceptions.RequestException as e: # ‚ùó Captura exce√ß√µes de requisi√ß√£o (e.g., falha de conex√£o, timeout, erro HTTP)
        print(Fore.RED + Style.BRIGHT + f"üî• Erro ao obter token ADMIN: {e}" + Style.RESET_ALL) # üî¥ Imprime mensagem de erro colorida no console
        return None # ‚ùå Retorna None para indicar que n√£o foi poss√≠vel obter o token

def colored_print_success(msg):
    """Imprime uma mensagem no console com formata√ß√£o de sucesso (verde e negrito)."""
    print(Fore.GREEN + Style.BRIGHT + "‚úÖ " + msg + Style.RESET_ALL) # ‚úÖ Imprime a mensagem em verde e negrito

def colored_print_failure(msg):
    """Imprime uma mensagem no console com formata√ß√£o de falha (vermelho e negrito)."""
    print(Fore.RED + Style.BRIGHT + "‚ùå " + msg + Style.RESET_ALL) # ‚ùå Imprime a mensagem em vermelho e negrito

def colored_print_info(msg):
    """Imprime uma mensagem no console com formata√ß√£o de informa√ß√£o (ciano e negrito)."""
    print(Fore.CYAN + Style.BRIGHT + "‚ÑπÔ∏è  " + msg + Style.RESET_ALL) # ‚ÑπÔ∏è Imprime a mensagem em ciano e negrito

def colored_print_warning(msg):
    """Imprime uma mensagem no console com formata√ß√£o de aviso (amarelo e negrito)."""
    print(Fore.YELLOW + Style.BRIGHT + "‚ö†Ô∏è  " + msg + Style.RESET_ALL) # ‚ö†Ô∏è Imprime a mensagem em amarelo e negrito

def colored_print_header(msg):
    """Imprime um cabe√ßalho formatado no console (fundo azul, texto branco e negrito)."""
    print(Back.BLUE + Fore.WHITE + Style.BRIGHT + " " + msg + " " + Style.RESET_ALL) # üîµ Imprime um cabe√ßalho com fundo azul, texto branco e negrito

class ApiTests(unittest.TestCase):
    """
    Classe que define a su√≠te de testes para a API Matem√°tica Segura.

    Herda de `unittest.TestCase` e cont√©m m√©todos de teste para diferentes endpoints da API,
    incluindo testes de sucesso, falha e valida√ß√£o de dados. Utiliza tokens JWT para testar
    endpoints protegidos e gera logs detalhados de cada teste executado.

    M√©todos:
        setUp(): Configura√ß√£o inicial para cada teste, obtendo token JWT e definindo headers.
        tearDown(): Limpeza ap√≥s cada teste, salvando logs e calculando a dura√ß√£o do teste.
        _start_test_logging(test_name): Inicia o logging para um caso de teste espec√≠fico.
        _log_request_response(method, url, headers, data, response): Loga detalhes de requisi√ß√£o e resposta HTTP.
        _save_log_to_file(): Salva as entradas de log acumuladas em um arquivo JSON.
        _testar_rota_post(url_path, token_headers, data, expected_status, expected_result_key, expected_result_value, test_name):
            M√©todo gen√©rico para testar rotas POST, validando status code e conte√∫do da resposta.
        test_rota_saude(): Testa o endpoint p√∫blico '/saude'.
        test_rota_somar_numeros_positivos(): Testa o endpoint '/somar' com n√∫meros positivos v√°lidos.
        test_rota_calcular_media_numeros_positivos(): Testa o endpoint '/calcular_media' com n√∫meros positivos v√°lidos.
        test_rota_somar_lista_vazia_erro_422(): Testa o endpoint '/somar' com lista vazia, esperando erro 422.
        test_rota_calcular_media_lista_vazia_retorna_none(): Testa o endpoint '/calcular_media' com lista vazia, esperando m√©dia None.
        ... (outros m√©todos de teste para diferentes cen√°rios e valida√ß√µes)
    """

    def setUp(self):
        """
        Configura√ß√£o inicial executada antes de cada m√©todo de teste.

        Obt√©m o token JWT de administrador se ainda n√£o estiver definido globalmente.
        Se o token n√£o for obtido, o teste √© pulado (skipTest). Define os headers de
        autoriza√ß√£o com o token JWT para as requisi√ß√µes aos endpoints protegidos.
        Inicializa a lista de entradas de log para cada teste (`self.log_entries`).
        """
        global ADMIN_TOKEN # üîë Indica que a vari√°vel global ADMIN_TOKEN ser√° acessada
        if not ADMIN_TOKEN: # ‚úÖ Verifica se o token ADMIN j√° foi obtido
            ADMIN_TOKEN = obter_token_admin() # üîë Obt√©m o token ADMIN chamando a fun√ß√£o obter_token_admin()
            if not ADMIN_TOKEN: # ‚ùå Se n√£o foi poss√≠vel obter o token ADMIN
                self.skipTest("Token ADMIN n√£o obtido, pulando testes protegidos.") # üö´ Pula todos os testes na classe ApiTests se o token ADMIN n√£o for obtido
        self.admin_token = ADMIN_TOKEN # üîë Armazena o token ADMIN na vari√°vel de inst√¢ncia para uso nos testes
        self.headers_admin = {"Authorization": f"Bearer {self.admin_token}"} # üõ°Ô∏è Define os headers de autoriza√ß√£o com o token JWT para endpoints protegidos
        self.log_entries = [] # üìù Inicializa a lista para armazenar as entradas de log dos testes

    def tearDown(self):
        """
        Executado ap√≥s cada m√©todo de teste para realizar a limpeza e logging.

        Calcula a dura√ß√£o do teste, determina o status (PASSOU/FALHOU) baseado em erros e falhas,
        cria uma entrada de log com os resultados do teste e salva essa entrada no arquivo de log JSON.
        Limpa a lista de entradas de log para o pr√≥ximo teste.
        """
        end_time = time.time() # ‚è±Ô∏è Marca o tempo de fim do teste
        test_duration = end_time - self.start_test_time # ‚è±Ô∏è Calcula a dura√ß√£o do teste em segundos
        status = "PASSOU" if not self._outcome.errors and not self._outcome.failures else "FALHOU" # ‚úÖ/‚ùå Determina o status do teste baseado em erros e falhas

        log_entry = { # üìù Cria uma entrada de log para o teste atual
            "test_name": self._testMethodName, # üè∑Ô∏è Nome do m√©todo de teste executado
            "status": status, # ‚úÖ/‚ùå Status do teste (PASSOU ou FALHOU)
            "duration_seconds": f"{test_duration:.4f}", # ‚è±Ô∏è Dura√ß√£o do teste formatada em segundos
            "timestamp": datetime.now().isoformat(), # üìÖ Timestamp da finaliza√ß√£o do teste em formato ISO
            "details": self.current_test_log # ‚ÑπÔ∏è Logs detalhados da requisi√ß√£o e resposta para este teste
        }
        self.log_entries.append(log_entry) # üìù Adiciona a entrada de log √† lista de logs
        self._save_log_to_file() # üíæ Salva os logs acumulados no arquivo

    def _start_test_logging(self, test_name):
        """Inicia o logging para um novo caso de teste, preparando para armazenar os logs."""
        self.current_test_log = [] # üìù Inicializa a lista para armazenar os logs do teste atual
        self.start_test_time = time.time() # ‚è±Ô∏è Marca o tempo de in√≠cio do teste

    def _log_request_response(self, method, url, headers, data, response):
        """
        Loga os detalhes de uma requisi√ß√£o e sua resposta para o log do teste atual.

        Armazena informa√ß√µes como m√©todo HTTP, URL, headers da requisi√ß√£o, dados enviados (se houver),
        status code da resposta, headers da resposta e o corpo da resposta (texto).

        Args:
            method (str): M√©todo HTTP da requisi√ß√£o (e.g., 'GET', 'POST').
            url (str): URL da requisi√ß√£o.
            headers (dict): Headers da requisi√ß√£o.
            data (dict | None): Dados enviados no corpo da requisi√ß√£o (para m√©todos como POST). Pode ser None.
            response (requests.Response): Objeto de resposta da requisi√ß√£o HTTP.
        """
        log_data = { # üìù Cria um dicion√°rio para armazenar os dados da requisi√ß√£o e resposta
            "request": { # ‚û°Ô∏è Dados da requisi√ß√£o
                "method": method, # ‚öôÔ∏è M√©todo HTTP (GET, POST, etc.)
                "url": url, # üîó URL da requisi√ß√£o
                "headers": headers, # ‚öôÔ∏è Headers da requisi√ß√£o
                "data": data if method == 'POST' else None, # üì¶ Dados enviados (se for requisi√ß√£o POST)
                "json": data if method == 'POST' else None # üì¶ Dados enviados como JSON (se for requisi√ß√£o POST)
            },
            "response": { # ‚¨ÖÔ∏è Dados da resposta
                "status_code": response.status_code, # üî¢ Status code HTTP da resposta
                "headers": dict(response.headers), # ‚öôÔ∏è Headers da resposta (convertidos para dict para serializa√ß√£o JSON)
                "body": response.text # üìÑ Corpo da resposta como texto
            }
        }
        self.current_test_log.append(log_data) # üìù Adiciona os dados de log √† lista de logs do teste atual

    def _save_log_to_file(self):
        """
        Salva as entradas de log acumuladas (de todos os testes executados) em um arquivo JSON.

        Verifica se o diret√≥rio de logs existe e o cria se necess√°rio. Adiciona um cabe√ßalho ao log
        com o timestamp da execu√ß√£o dos testes e o nome da su√≠te de testes. Formata as entradas de log
        em JSON e as escreve no arquivo, garantindo que seja um JSON v√°lido mesmo com m√∫ltiplas execu√ß√µes.
        Limpa a lista de entradas de log ap√≥s salvar no arquivo.
        """
        if not os.path.exists(LOG_DIR): # üìÅ Verifica se o diret√≥rio de logs existe
            os.makedirs(LOG_DIR) # üìÅ Cria o diret√≥rio de logs se n√£o existir
        log_header = {"test_run_timestamp": datetime.now().isoformat(), "test_suite": "ApiTests"} # üìù Cabe√ßalho do log com timestamp e nome da su√≠te

        try:
            file_exists = os.path.exists(LOG_FILE) # ‚úÖ Verifica se o arquivo de log j√° existe
            with open(LOG_FILE, 'a') as f: # üìù Abre o arquivo de log em modo de append ('a')
                if not file_exists: # üÜï Se o arquivo n√£o existia, inicia o JSON com o cabe√ßalho 'test_runs'
                    f.write('{"test_runs": [\n') # üìù In√≠cio da estrutura JSON 'test_runs'
                else: # ‚ûï Se o arquivo j√° existia, adiciona uma v√≠rgula para separar a execu√ß√£o anterior
                    f.write(',\n') # üìù Adiciona v√≠rgula para separar as execu√ß√µes no array 'test_runs'

                json.dump(log_header, f, indent=4, ensure_ascii=False) # üìù Escreve o cabe√ßalho do log em JSON formatado
                f.write(',\n"tests": [\n') # üìù In√≠cio do array 'tests' dentro de cada 'test_run'

                for i, entry in enumerate(self.log_entries): # üìù Itera sobre cada entrada de log na lista
                    json.dump(entry, f, indent=4, ensure_ascii=False) # üìù Escreve a entrada de log em JSON formatado
                    if i < len(self.log_entries) - 1: # ‚ûï Adiciona v√≠rgula se n√£o for a √∫ltima entrada para separar os testes
                        f.write(',') # üìù Adiciona v√≠rgula entre as entradas de teste no array 'tests'
                    f.write('\n') # üìù Nova linha para formata√ß√£o

                f.write(']\n}') # üìù Fecha o array 'tests' e o objeto 'test_runs'
                self.log_entries = [] # üìù Limpa a lista de entradas de log ap√≥s salvar no arquivo

        except Exception as e: # ‚ùó Captura exce√ß√µes que podem ocorrer ao salvar o log
            colored_print_failure(f"‚ùå Erro ao salvar log em '{LOG_FILE}': {e}") # ‚ùå Imprime mensagem de erro no console se falhar ao salvar o log

    def _testar_rota_post(self, url_path, token_headers, data, expected_status=200, expected_result_key=None, expected_result_value=None, test_name="Rota POST"):
        """
        M√©todo gen√©rico para testar endpoints POST da API, validando status code e corpo da resposta.

        Faz uma requisi√ß√£o POST para a URL especificada, com headers e dados fornecidos.
        Verifica se o status code da resposta corresponde ao esperado. Se um `expected_result_key`
        for fornecido, tenta validar se a chave existe na resposta JSON e, opcionalmente, se o valor
        associado a essa chave corresponde a `expected_result_value`. Em caso de falha em qualquer
        valida√ß√£o, imprime mensagens de erro coloridas no console e registra a falha no teste.

        Args:
            url_path (str): Caminho da URL do endpoint a ser testado (relativo √† URL base da API).
            token_headers (dict): Headers HTTP a serem inclu√≠dos na requisi√ß√£o, geralmente contendo o token JWT.
            data (dict): Dados a serem enviados no corpo da requisi√ß√£o POST (em formato JSON).
            expected_status (int, optional): Status code HTTP esperado na resposta. Padr√£o: 200.
            expected_result_key (str, optional): Chave esperada no JSON da resposta para valida√ß√£o do valor. Padr√£o: None.
            expected_result_value (any, optional): Valor esperado para a chave `expected_result_key` no JSON da resposta. Padr√£o: None.
            test_name (str, optional): Nome descritivo para o teste, usado nas mensagens de log e console. Padr√£o: "Rota POST".

        Returns:
            requests.Response: O objeto de resposta da requisi√ß√£o HTTP para inspe√ß√£o adicional, se necess√°rio.
        """
        url = f"{API_BASE_URL}{url_path}" # üîó Constr√≥i a URL completa do endpoint
        self._start_test_logging(test_name) # üìù Inicia o logging para este teste

        resposta = requests.post(url, headers=token_headers, json=data, verify=VERIFY_SSL_CERT) # üìß Faz a requisi√ß√£o POST para o endpoint
        self._log_request_response('POST', url, token_headers, data, resposta) # üìù Loga os detalhes da requisi√ß√£o e resposta

        if resposta.status_code != expected_status: # ‚ùå Verifica se o status code da resposta √© o esperado
            colored_print_failure(f"‚ùå {test_name} FALHOU: Status code incorreto. Esperado: {expected_status}, Obtido: {resposta.status_code}. Response Body: {resposta.text}") # üî¥ Imprime mensagem de falha no console
            self.assertEqual(resposta.status_code, expected_status) # üö® Falha no teste se o status code estiver incorreto
            return # üõë Retorna imediatamente em caso de falha no status code

        if expected_status < 400 and expected_result_key: # ‚úÖ Se o status code for de sucesso (2xx, 3xx) e uma chave de resultado esperada for fornecida
            try:
                response_json = resposta.json() # üóÑÔ∏è Tenta decodificar o corpo da resposta como JSON
                actual_value = response_json.get(expected_result_key) # üîë Obt√©m o valor da chave esperada do JSON da resposta
                if expected_result_value is not None: # ‚úÖ Se um valor de resultado esperado espec√≠fico for fornecido
                    if actual_value == expected_result_value: # ‚úÖ Verifica se o valor obtido corresponde ao valor esperado
                        colored_print_success(f"‚úÖ {test_name} OK: Valor de '{expected_result_key}' validado. ({expected_result_value})") # üü¢ Imprime mensagem de sucesso no console
                    else: # ‚ùå Se o valor obtido n√£o corresponder ao valor esperado
                        colored_print_failure(f"‚ùå {test_name} FALHOU: Valor incorreto para chave '{expected_result_key}'. Esperado: {expected_result_value}, Obtido: {actual_value}. Response: {response_json}") # üî¥ Imprime mensagem de falha no console
                        self.fail(f"Valor incorreto para chave '{expected_result_key}'. Esperado: {expected_result_value}, Obtido: {actual_value}") # üö® Falha no teste se o valor estiver incorreto
                else: # ‚úÖ Se apenas a presen√ßa da chave for verificada (sem valor espec√≠fico)
                    if expected_result_key in response_json: # ‚úÖ Verifica se a chave esperada est√° presente no JSON da resposta
                        colored_print_success(f"‚úÖ {test_name} OK: Chave '{expected_result_key}' presente na resposta.") # üü¢ Imprime mensagem de sucesso no console
                    else: # ‚ùå Se a chave esperada estiver ausente na resposta JSON
                        colored_print_failure(f"‚ùå {test_name} FALHOU: Chave '{expected_result_key}' ausente na resposta JSON. Response: {response_json}") # üî¥ Imprime mensagem de falha no console
                        self.fail(f"Chave '{expected_result_key}' ausente na resposta JSON.") # üö® Falha no teste se a chave estiver ausente
            except json.JSONDecodeError: # ‚ùó Captura exce√ß√£o se houver erro ao decodificar o JSON da resposta
                self.fail(f"‚ùå {test_name} FALHOU: Erro ao decodificar JSON. Response text: {resposta.text}") # üö® Falha no teste se a resposta n√£o for um JSON v√°lido
        return resposta # ‚û°Ô∏è Retorna o objeto de resposta para inspe√ß√£o adicional

    def test_rota_saude(self):
        """Testa o endpoint p√∫blico '/saude' para verificar se a API est√° saud√°vel."""
        resposta = requests.get(f"{API_BASE_URL}/saude", verify=VERIFY_SSL_CERT) # üìß Faz requisi√ß√£o GET para o endpoint /saude
        self.assertEqual(resposta.status_code, 200, colored_print_failure(f"Rota /saude falhou, status code: {resposta.status_code}")) # üö® Falha se o status code n√£o for 200
        if resposta.status_code == 200: # ‚úÖ Se o status code for 200 (OK)
            try:
                response_json = resposta.json() # üóÑÔ∏è Tenta decodificar a resposta como JSON
                if response_json.get("status") == "OK": # ‚úÖ Verifica se o status no JSON √© 'OK'
                    colored_print_success(f"‚úÖ Teste /saude OK: Status 'OK' encontrado na resposta JSON.") # üü¢ Imprime mensagem de sucesso
                else: # ‚ùå Se o status n√£o for 'OK'
                    colored_print_failure(f"‚ùå /saude - status incorreto na resposta JSON. Esperado 'OK', obtido: '{response_json.get('status')}'") # üî¥ Imprime mensagem de falha com o status incorreto
                    self.assertEqual(response_json.get("status"), "OK") # üö® Falha se o status JSON n√£o for 'OK'

                if "mensagem" in response_json: # ‚úÖ Verifica se a chave 'mensagem' est√° presente no JSON
                    colored_print_success(f"‚úÖ Teste /saude OK: Chave 'mensagem' encontrada na resposta JSON.") # üü¢ Imprime mensagem de sucesso
                else: # ‚ùå Se a chave 'mensagem' estiver ausente
                    colored_print_failure(f"‚ùå /saude - chave 'mensagem' ausente na resposta JSON.") # üî¥ Imprime mensagem de falha informando que a chave est√° ausente
                    self.assertIn("mensagem", response_json) # üö® Falha se a chave 'mensagem' estiver ausente

                if "version" in response_json: # ‚úÖ Verifica se a chave 'version' est√° presente no JSON
                    colored_print_success(f"‚úÖ Teste /saude OK: Chave 'version' encontrada na resposta JSON.") # üü¢ Imprime mensagem de sucesso
                else: # ‚ö†Ô∏è Se a chave 'version' estiver ausente (pode ser opcional)
                    colored_print_warning(f"‚ö†Ô∏è /saude - chave 'version' ausente na resposta JSON (pode ser opcional).") # üü° Imprime mensagem de aviso indicando que a chave est√° ausente (aviso, n√£o falha)

            except json.JSONDecodeError: # ‚ùó Captura exce√ß√£o se a resposta n√£o for um JSON v√°lido
                colored_print_failure(f"‚ùå /saude - Resposta n√£o √© um JSON v√°lido: {resposta.text}") # üî¥ Imprime mensagem de falha se a resposta n√£o for JSON
                self.fail("Resposta /saude n√£o √© um JSON v√°lido") # üö® Falha no teste se a resposta n√£o for JSON v√°lida
        else: # ‚ùå Se o status code da resposta n√£o for 200
            colored_print_failure(f"‚ùå Rota /saude falhou, status code: {resposta.status_code}") # üî¥ Imprime mensagem de falha com o status code incorreto

    def test_rota_somar_numeros_positivos(self):
        """Testa o endpoint '/somar' com uma lista de n√∫meros inteiros positivos v√°lidos."""
        numeros = [1, 2, 3, 4, 5] # üî¢ Lista de n√∫meros positivos para o teste
        soma_esperada = sum(numeros) # ‚ûï Calcula a soma esperada dos n√∫meros
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="resultado", expected_result_value=soma_esperada, test_name="/somar n√∫meros positivos") # üß™ Executa o teste gen√©rico da rota POST para '/somar'

    def test_rota_calcular_media_numeros_positivos(self):
        """Testa o endpoint '/calcular_media' com uma lista de n√∫meros inteiros positivos v√°lidos."""
        numeros = [1, 2, 3, 4, 5] # üî¢ Lista de n√∫meros positivos para o teste
        media_esperada = sum(numeros) / len(numeros) # ‚ûó Calcula a m√©dia esperada dos n√∫meros
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="media", expected_result_value=media_esperada, test_name="/calcular_media n√∫meros positivos") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media'

    def test_rota_somar_lista_vazia_erro_422(self):
        """Testa o endpoint '/somar' com uma lista vazia, esperando um erro de status 422."""
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": []}, expected_status=422, test_name="/somar lista vazia (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/somar' com lista vazia e status 422 esperado

    def test_rota_calcular_media_lista_vazia_retorna_none(self):
        """Testa o endpoint '/calcular_media' com uma lista vazia, esperando que retorne m√©dia como None."""
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": []}, expected_status=200, expected_result_key="media", expected_result_value=None, test_name="/calcular_media lista vazia (media None)") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media' com lista vazia e m√©dia None esperada

    def test_rota_somar_input_nao_lista_erro_422(self):
        """Testa o endpoint '/somar' com um input que n√£o √© uma lista, esperando um erro 422."""
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": "string"}, expected_status=422, test_name="/somar input n√£o lista (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/somar' com input string e status 422 esperado

    def test_rota_calcular_media_input_nao_lista_erro_422(self):
        """Testa o endpoint '/calcular_media' com um input que n√£o √© uma lista, esperando um erro 422."""
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": "string"}, expected_status=422, test_name="/calcular_media input n√£o lista (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media' com input string e status 422 esperado

    def test_rota_somar_lista_com_nao_inteiros_erro_422(self):
        """Testa o endpoint '/somar' com uma lista contendo elementos n√£o inteiros, esperando erro 422."""
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": [1, 2, "a", 4]}, expected_status=422, test_name="/somar lista com n√£o inteiros (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/somar' com lista de n√£o inteiros e status 422 esperado

    def test_rota_calcular_media_lista_com_nao_inteiros_erro_422(self):
        """Testa o endpoint '/calcular_media' com uma lista contendo elementos n√£o inteiros, esperando erro 422."""
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": [1, 2, "a", 4]}, expected_status=422, test_name="/calcular_media lista com n√£o inteiros (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media' com lista de n√£o inteiros e status 422 esperado

    def test_rota_somar_lista_com_none_erro_422(self):
        """Testa o endpoint '/somar' com uma lista contendo o valor None, esperando erro 422."""
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": [1, 2, None, 4]}, expected_status=422, test_name="/somar lista com None (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/somar' com lista contendo None e status 422 esperado

    def test_rota_calcular_media_lista_com_none_erro_422(self):
        """Testa o endpoint '/calcular_media' com uma lista contendo o valor None, esperando erro 422."""
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": [1, 2, None, 4]}, expected_status=422, test_name="/calcular_media lista com None (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media' com lista contendo None e status 422 esperado

    def test_rota_somar_lista_com_float_como_string_erro_422(self):
        """Testa o endpoint '/somar' com uma lista contendo um float como string (e.g., "2.5"), esperando erro 422."""
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": [1, 2, "2.5", 4]}, expected_status=422, test_name="/somar lista float string (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/somar' com lista contendo float string e status 422 esperado

    def test_rota_calcular_media_lista_com_float_como_string_erro_422(self):
        """Testa o endpoint '/calcular_media' com uma lista contendo um float como string (e.g., "2.5"), esperando erro 422."""
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": [1, 2, "2.5", 4]}, expected_status=422, test_name="/calcular_media lista float string (erro 422)") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media' com lista contendo float string e status 422 esperado

    def test_rota_somar_lista_com_string_int_ok(self):
        """Testa o endpoint '/somar' com uma lista contendo strings que representam inteiros, esperando sucesso."""
        numeros = [1, 2, "3", 4] # üî¢ Lista contendo strings que s√£o inteiros
        soma_esperada = sum([1, 2, 3, 4]) # ‚ûï Calcula a soma esperada (convertendo strings para int)
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="resultado", expected_result_value=soma_esperada, test_name="/somar lista com string int (OK)") # üß™ Executa o teste gen√©rico da rota POST para '/somar' com lista de string int e sucesso esperado

    def test_rota_calcular_media_lista_com_string_int_ok(self):
        """Testa o endpoint '/calcular_media' com uma lista contendo strings que representam inteiros, esperando sucesso."""
        numeros = [1, 2, "3", 4] # üî¢ Lista contendo strings que s√£o inteiros
        media_esperada = sum([1, 2, 3, 4]) / len([1, 2, 3, 4]) # ‚ûó Calcula a m√©dia esperada (convertendo strings para int)
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="media", expected_result_value=media_esperada, test_name="/calcular_media lista string int (OK)") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media' com lista de string int e sucesso esperado

    def test_rota_somar_lista_com_float_int_string_ok(self):
        """Testa o endpoint '/somar' com uma lista mista de floats (como int), ints e strings de inteiros, esperando sucesso."""
        numeros = [1, 2.0, "3", 4] # üî¢ Lista mista de floats (como int), ints e strings de inteiros
        soma_esperada = sum([1, 2, 3, 4]) # ‚ûï Calcula a soma esperada (convertendo floats e strings para int)
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="resultado", expected_result_value=soma_esperada, test_name="/somar lista float int string (OK)") # üß™ Executa o teste gen√©rico da rota POST para '/somar' com lista mista e sucesso esperado

    def test_rota_calcular_media_lista_com_float_int_string_ok(self):
        """Testa o endpoint '/calcular_media' com uma lista mista de floats (como int), ints e strings de inteiros, esperando sucesso."""
        numeros = [1, 2.0, "3", 4] # üî¢ Lista mista de floats (como int), ints e strings de inteiros
        media_esperada = sum([1, 2, 3, 4]) / len([1, 2, 3, 4]) # ‚ûó Calcula a m√©dia esperada (convertendo floats e strings para int)
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="media", expected_result_value=media_esperada, test_name="/calcular_media lista float int string (OK)") # üß™ Executa o teste gen√©rico da rota POST para '/calcular_media' com lista mista e sucesso esperado

if __name__ == "__main__":
    """Executa a su√≠te de testes quando o script √© rodado diretamente."""
    suite = unittest.TestSuite() # üß™ Cria uma su√≠te de testes
    suite.addTest(unittest.makeSuite(ApiTests)) # üß™ Adiciona todos os testes da classe ApiTests √† su√≠te

    runner = unittest.TextTestRunner(verbosity=2) # üèÉ‚Äç‚ôÇÔ∏è Cria um runner de testes de texto com verbosidade 2 (mais detalhes na sa√≠da)
    test_results = runner.run(suite) # üèÉ‚Äç‚ôÇÔ∏è Executa a su√≠te de testes e obt√©m os resultados