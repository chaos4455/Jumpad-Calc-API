# Documenta√ß√£o do Projeto

Este documento foi gerado automaticamente pelo script `documentador_projeto.py`.

Data de Gera√ß√£o: 2025-03-10 00:32:48
Diret√≥rio Raiz: D:\projeto jumpad

================================================================================

üìÇ Pasta: .\app

üìÇ Pasta: .\bibliotecas

üìÇ Pasta: .\config

üìÇ Pasta: .\credentials

üìÇ Pasta: .\docs

üìÇ Pasta: .\exceptions

üìÇ Pasta: .\logs

üìÇ Pasta: .\schemas

üìÇ Pasta: .\tests

üìÇ Pasta: .\test_logs

üìÑ Arquivo: .\.gitignore
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√∫mero de Linhas: 0
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\CHANGELOG.md
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√∫mero de Linhas: 0

  C√≥digo Fonte:

üìÑ Arquivo: .\Dockerfile
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√∫mero de Linhas: 0
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\doc_gen.py
  Tamanho: 0.00 MB (2.06 KB, 2108 bytes)
  N√∫mero de Linhas: 42

  C√≥digo Fonte:
import os
import datetime

def document_project_structure(start_path="."):
    docs_dir = os.path.join(start_path, "docs")
    doc_file_path = os.path.join(docs_dir, "project_structure.txt")

    if not os.path.exists(docs_dir):
        os.makedirs(docs_dir)
        print(f"Diret√≥rio 'docs/' criado.")

    with open(doc_file_path, 'w', encoding='utf-8') as doc_file:
        doc_file.write("DOCUMENTA√á√ÉO AUTOM√ÅTICA DA ESTRUTURA DO PROJETO\n")
        doc_file.write("---------------------------------------------------\n")
        doc_file.write(f"Gerado por: {os.path.basename(__file__)}\n")
        doc_file.write("Data de Gera√ß√£o: {:%d/%m/%Y %H:%M:%S}\n".format(datetime.datetime.now()))
        doc_file.write("Codifica√ß√£o do Arquivo: UTF-8\n")
        doc_file.write("\nEstrutura de diret√≥rios e arquivos a partir da raiz do projeto:\n\n")

        for root, dirs, files in os.walk(start_path):
            depth = root.replace(start_path, '').count(os.sep)
            indent = '  ' * depth
            doc_file.write(f"{indent}{os.path.basename(root)}/\n")

            sub_indent = '  ' * (depth + 1)
            for filename in files:
                if filename != os.path.basename(__file__):
                    doc_file.write(f"{sub_indent}{filename}\n")

        doc_file.write("\n---------------------------------------------------\n")
        doc_file.write("Fim da Documenta√ß√£o da Estrutura do Projeto.\n")
        doc_file.write("\nEste arquivo foi gerado automaticamente. Para atualizar a documenta√ß√£o,\n")
        doc_file.write("execute o script novamente: 'python {}'\n".format(os.path.basename(__file__)))
        doc_file.write("Certifique-se de que seu editor de texto/visualizador utilize UTF-8 para exibir corretamente os caracteres.\n")

    print(f"\nDocumenta√ß√£o da estrutura do projeto gerada com sucesso em: '{doc_file_path}' (Codifica√ß√£o: UTF-8)")


if __name__ == "__main__":
    print("Gerando documenta√ß√£o da estrutura do projeto (UTF-8)...")
    document_project_structure()
    print("\nProcesso conclu√≠do.")
üìÑ Arquivo: .\doc_gen_full.py
  Tamanho: 0.01 MB (8.60 KB, 8805 bytes)
  N√∫mero de Linhas: 192

  C√≥digo Fonte:
import os
import sqlite3
import chardet
import datetime

# Define o nome da pasta 'docs' e o caminho completo para o arquivo de sa‚àö‚â†da
DOCS_FOLDER = "docs"
OUTPUT_FILE = os.path.join(DOCS_FOLDER, "docproject.txt")
SAMPLE_SIZE = 3
LARGE_TABLE_THRESHOLD = 100

def detect_encoding(filepath):
    try:
        with open(filepath, 'rb') as f:
            rawdata = f.read()
            result = chardet.detect(rawdata)
            return result['encoding']
    except Exception:
        return 'utf-8'

def get_file_info(filepath):
    size_bytes = os.path.getsize(filepath)
    size_kb = size_bytes / 1024
    size_mb = size_kb / 1024

    line_count = 0
    try:
        encoding = detect_encoding(filepath)
        with open(filepath, 'r', encoding=encoding, errors='ignore') as f:
            for line in f:
                line_count += 1
    except Exception as e:
        print(f"Aviso: Erro ao contar linhas de '{filepath}': {e}")
        line_count = -1

    return {
        "tamanho_bytes": size_bytes,
        "tamanho_kb": f"{size_kb:.2f}",
        "tamanho_mb": f"{size_mb:.2f}",
        "numero_linhas": line_count
    }

def get_file_content_bruto(filepath):
    try:
        encoding = detect_encoding(filepath)
        with open(filepath, 'r', encoding=encoding, errors='ignore') as f:
            return f.read()
    except Exception as e:
        print(f"Aviso: Erro ao ler conte‚àö‚à´do de '{filepath}': {e}")
        return "[ERRO AO LER CONTE‚àö√∂DO]"

def analyze_sqlite_db(filepath, doc_file):
    conn = None
    try:
        conn = sqlite3.connect(filepath)
        cursor = conn.cursor()

        doc_file.write("\n" + "="*80 + "\n")
        doc_file.write(f"  Ô£ø√º√≠√¶ Banco de Dados SQLite: {filepath}\n")
        doc_file.write("="*80 + "\n")

        db_size_bytes = os.path.getsize(filepath)
        db_size_kb = db_size_bytes / 1024
        db_size_mb = db_size_kb / 1024

        doc_file.write(f"  Tamanho: {db_size_mb:.2f} MB ({db_size_kb:.2f} KB, {db_size_bytes} bytes)\n")

        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()

        if tables:
            doc_file.write(f"\n  Tabelas:\n")
            for table_name_tuple in tables:
                table_name = table_name_tuple[0]
                doc_file.write(f"\n    Ô£ø√º√≥√á√î‚àè√® Tabela: {table_name}\n")

                cursor.execute(f"PRAGMA table_info('{table_name}')")
                columns_info = cursor.fetchall()
                if columns_info:
                    doc_file.write(f"    Colunas:\n")
                    doc_file.write("    " + "-"*74 + "\n")
                    doc_file.write(f"    | {'ID':<4} | {'Nome':<20} | {'Tipo':<15} | {'N‚àö¬£o Nulo?':<10} | {'Padr‚àö¬£o':<10} | {'PK':<3} |\n")
                    doc_file.write("    " + "-"*74 + "\n")

                    for col_info in columns_info:
                        cid, name, type_str, notnull, dflt_value, pk = col_info
                        doc_file.write(f"    | {cid:<4} | {name:<20} | {type_str:<15} | {'Sim' if notnull else 'N‚àö¬£o':<10} | {str(dflt_value):<10} | {'Sim' if pk else 'N‚àö¬£o':<3} |\n")
                    doc_file.write("    " + "-"*74 + "\n")


                cursor.execute(f"SELECT COUNT(*) FROM '{table_name}'")
                row_count = cursor.fetchone()[0]
                doc_file.write(f"    N‚àö‚à´mero de Registros: {row_count}\n")

                if row_count > 0:
                    doc_file.write(f"    Amostra de Dados:\n")

                    doc_file.write(f"      Topo ({SAMPLE_SIZE} registros):\n")
                    cursor.execute(f"SELECT * FROM '{table_name}' LIMIT {SAMPLE_SIZE}")
                    top_rows = cursor.fetchall()
                    if top_rows:
                        header_row = [col_info[1] for col_info in columns_info]
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                        doc_file.write("      | " + " | ".join([f'{header:<20}' for header in header_row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")

                        for row in top_rows:
                            doc_file.write("      | " + " | ".join([f'{str(item):<20}' for item in row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")


                    doc_file.write(f"      Fundo ({SAMPLE_SIZE} registros):\n")
                    cursor.execute(f"SELECT * FROM '{table_name}' ORDER BY ROWID DESC LIMIT {SAMPLE_SIZE}")
                    bottom_rows = cursor.fetchall()
                    if bottom_rows:
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                        doc_file.write("      | " + " | ".join([f'{header:<20}' for header in header_row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                        for row in bottom_rows:
                            doc_file.write("      | " + " | ".join([f'{str(item):<20}' for item in row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")

                    if row_count > LARGE_TABLE_THRESHOLD:
                        doc_file.write(f"      Meio ({SAMPLE_SIZE} registros):\n")
                        offset = row_count // 2 - (SAMPLE_SIZE // 2) if row_count > SAMPLE_SIZE else 0
                        if offset < 0: offset = 0
                        cursor.execute(f"SELECT * FROM '{table_name}' LIMIT {SAMPLE_SIZE} OFFSET {offset}")
                        middle_rows = cursor.fetchall()
                        if middle_rows:
                            doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                            doc_file.write("      | " + " | ".join([f'{header:<20}' for header in header_row]) + " |\n")
                            doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                            for row in middle_rows:
                                doc_file.write("      | " + " | ".join([f'{str(item):<20}' for item in row]) + " |\n")
                            doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")


        else:
            doc_file.write(f"  Nenhuma tabela encontrada neste banco de dados.\n")


    except sqlite3.Error as e:
        doc_file.write(f"Erro ao analisar banco de dados SQLite '{filepath}': {e}\n")
    finally:
        if conn:
            conn.close()

def main():
    root_dir = "."
    print("‚Äö√∂√¥√î‚àè√® Iniciando An‚àö¬∞lise do Projeto ‚Äö√∂√¥√î‚àè√®")

    # Cria a pasta 'docs' se ela n‚àö¬£o existir
    if not os.path.exists(DOCS_FOLDER):
        os.makedirs(DOCS_FOLDER)

    with open(OUTPUT_FILE, 'w', encoding='utf-8') as doc_file:
        doc_file.write(f"# Documenta‚àö√ü‚àö¬£o do Projeto\n\n")
        doc_file.write(f"Este documento foi gerado automaticamente pelo script `documentador_projeto.py`.\n\n")
        doc_file.write(f"Data de Gera‚àö√ü‚àö¬£o: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        doc_file.write(f"Diret‚àö‚â•rio Raiz: {os.path.abspath(root_dir)}\n\n")
        doc_file.write("="*80 + "\n")

        for root, dirs, files in os.walk(root_dir):
            for dir_name in dirs:
                folder_path = os.path.join(root, dir_name)
                doc_file.write(f"\nÔ£ø√º√¨√á Pasta: {folder_path}\n")

            for file_name in files:
                filepath = os.path.join(root, file_name)
                file_ext = file_name.lower().split('.')[-1]

                doc_file.write(f"\nÔ£ø√º√¨√ë Arquivo: {filepath}\n")

                file_info = get_file_info(filepath)
                doc_file.write(f"  Tamanho: {file_info['tamanho_mb']} MB ({file_info['tamanho_kb']} KB, {file_info['tamanho_bytes']} bytes)\n")
                doc_file.write(f"  N‚àö‚à´mero de Linhas: {file_info['numero_linhas']}\n")

                if file_ext in ('py', 'txt', 'js', 'html', 'css', 'java', 'c', 'cpp', 'h', 'sh', 'sql', 'md'):
                    doc_file.write(f"\n  C‚àö‚â•digo Fonte:\n")
                    code_content = get_file_content_bruto(filepath)
                    doc_file.write(code_content)
                else:
                    doc_file.write(f"  Conte‚àö‚à´do n‚àö¬£o textual ou extens‚àö¬£o n‚àö¬£o suportada para visualiza‚àö√ü‚àö¬£o do c‚àö‚â•digo fonte.\n")

                if file_ext in ('db', 'sqlite', 'sqlite3'):
                    analyze_sqlite_db(filepath, doc_file)

    print("‚Äö√∫√ñ Documenta‚àö√ü‚àö¬£o Gerada com Sucesso! ‚Äö√∫√ñ")
    print(f"Arquivo de documenta‚àö√ü‚àö¬£o salvo em: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
üìÑ Arquivo: .\README.md
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√∫mero de Linhas: 0

  C√≥digo Fonte:

üìÑ Arquivo: .\requirements.txt
  Tamanho: 0.00 MB (0.16 KB, 167 bytes)
  N√∫mero de Linhas: 10

  C√≥digo Fonte:
fastapi
uvicorn
python-jose[cryptography]  
cryptography              
requests
pytest
colorama
python-dotenv             
pydantic                  
inquirer
üìÑ Arquivo: .\app\API-main-server-mvp.py
  Tamanho: 0.02 MB (24.25 KB, 24831 bytes)
  N√∫mero de Linhas: 321

  C√≥digo Fonte:
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import logging
import json
from datetime import datetime, timedelta
from typing import List, Optional, Any
from fastapi import FastAPI, Request, HTTPException, Depends, status
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, ValidationError
from jose import JWTError, jwt
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from bibliotecas.calc_numbers import Numbers
SECRET_KEY = os.environ.get("API_SECRET_KEY", "Jump@d2025!!(SegredoSuperSeguroParaTesteAPI)")
ALGORITHM = os.environ.get("API_JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.environ.get("API_TOKEN_EXPIRY_MINUTES", "30"))
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token_admin")
oauth2_scheme_tester = OAuth2PasswordBearer(tokenUrl="token_tester")
RATE_LIMIT_REQUESTS_PER_MINUTE = int(os.environ.get("API_RATE_LIMIT", "200"))
RATE_LIMIT_STORAGE = {}
DIRETORIO_LOGS = os.environ.get("API_LOG_DIR", "logs")
if not os.path.exists(DIRETORIO_LOGS):
    os.makedirs(DIRETORIO_LOGS)
ARQUIVO_LOG_API = os.path.join(DIRETORIO_LOGS, "api-logs.json")
ARQUIVO_LOG_DETALHADO_API = os.path.join(DIRETORIO_LOGS, "api-detailed-logs.json")
class FormatterColoridoSeguro(logging.Formatter):
    CORES = {
        'DEBUG': '\033[94m',    'INFO': '\033[92m',     'WARNING': '\033[93m',
        'ERROR': '\033[91m',    'CRITICAL': '\033[97;41m', 'RESET': '\033[0m'
    }
    EMOJIS = {
        'DEBUG': 'Ô£ø√º√™√µ', 'INFO': '‚Äö√∫√ñ', 'WARNING': '‚Äö√∂‚Ä†√î‚àè√®', 'ERROR': 'Ô£ø√º√Æ‚Ä¢', 'CRITICAL': 'Ô£ø√º√∂¬Æ'
    }
    def format(self, record):
        cor_log = self.CORES.get(record.levelname, self.CORES['INFO'])
        reset_cor = self.CORES['RESET']
        emoji = self.EMOJIS.get(record.levelname, '')
        nivel_log = f"{cor_log}{record.levelname}{reset_cor}"
        mensagem = f"{cor_log}{record.getMessage()}{reset_cor}"
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"{timestamp} - {emoji} {nivel_log} - {record.name}:{record.lineno} - {mensagem}"
console_handler = logging.StreamHandler()
console_handler.setFormatter(FormatterColoridoSeguro())
api_log_handler = logging.FileHandler(ARQUIVO_LOG_API, encoding='utf-8')
api_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s", "detalhes": %(log_record_json)s}')
api_log_handler.setFormatter(api_log_formatter)
api_detailed_log_handler = logging.FileHandler(ARQUIVO_LOG_DETALHADO_API, encoding='utf-8')
api_detailed_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "name": "%(name)s", "line": "%(lineno)d", "message": "%(message)s", "record": %(log_record_json)s}')
api_detailed_log_handler.setFormatter(api_detailed_log_formatter)
logger_app = logging.getLogger("api_server")
logger_app.setLevel(logging.DEBUG)
logger_app.addHandler(console_handler)
logger_app.addHandler(api_log_handler)
logger_app.addHandler(api_detailed_log_handler)
app = FastAPI(title="API Matem‚àö¬∞tica Segura", description="API RESTful para opera‚àö√ü‚àö¬µes de soma e m‚àö¬©dia - SEGURA (N‚àö‚â†vel M‚àö¬∞ximo)", version="0.9.3", default_response_class=JSONResponse)
origins_permitidas = os.environ.get("API_CORS_ORIGINS", "http://localhost").split(",")
class NumerosEntrada(BaseModel):
    numeros: List[int]
    model_config = {
        "json_schema_extra": {
            "examples": [
                {"numeros": [1, 2, 3, 4]}
            ]
        }
    }
class TokenRequest(BaseModel):
    username: str
    password: str
class SomaResponse(BaseModel):
    resultado: int
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"resultado": 10, "mensagem": "Opera‚àö√ü‚àö¬£o de soma bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"}
            ]
        }
class MediaResponse(BaseModel):
    media: Optional[float] = None
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"media": 2.5, "mensagem": "Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"}
            ]
        }
class SaudeResponse(BaseModel):
    status: str
    mensagem: str
    class Config:
        json_schema_extra = {
            "examples": [
                {"status": "OK", "mensagem": "API est‚àö¬∞ saud‚àö¬∞vel e SEGURA"}
            ]
        }
class TokenResponse(BaseModel):
    access_token: str
    token_type: str
    nivel_acesso: str
    class Config:
        json_schema_extra = {
            "examples": [
                {"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "token_type": "bearer", "nivel_acesso": "admin"}
            ]
        }
class ErrorResponse(BaseModel):
    erro: str
    detalhes: Any
    class Config:
        json_schema_extra = {
            "examples": [
                {"erro": "Erro de valida‚àö√ü‚àö¬£o nos dados de entrada", "detalhes": "A lista de n‚àö‚à´meros n‚àö¬£o pode estar vazia."}
            ]
        }
def gerar_token_jwt(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
        to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
def verificar_token_jwt(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
async def obter_usuario_atual_jwt(token: str = Depends(oauth2_scheme)):
    logger_app.debug(f"Ô£ø√º√Æ√≠ Validando Token JWT (ADMIN): {token[:10]}...", extra={'log_record_json': {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("‚Äö√∂‚Ä†√î‚àè√® Token JWT inv‚àö¬∞lido ou expirado (ADMIN). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_admin"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv‚àö¬∞lidas. Token JWT ausente, inv‚àö¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload
async def obter_usuario_tester_jwt(token: str = Depends(oauth2_scheme_tester)):
    logger_app.debug(f"Ô£ø√º√Æ√≠ Validando Token JWT (TESTER): {token[:10]}...", extra={'log_record_json':  {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("‚Äö√∂‚Ä†√î‚àè√® Token JWT inv‚àö¬∞lido ou expirado (TESTER). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_tester"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv‚àö¬∞lidas. Token JWT de tester ausente, inv‚àö¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload
@app.post("/token_admin", tags=["autentica‚àö√ü‚àö¬£o_segura"], response_model=TokenResponse, summary="Gera token JWT seguro (credenciais 'admin/admin')")
async def gerar_token_admin_seguro(token_request: TokenRequest):
    logger_app.info(f"Ô£ø√º√Æ√´ Requisi‚àö√ü‚àö¬£o para gerar token JWT (ADMIN) recebida para usu‚àö¬∞rio: '{token_request.username}'", extra={'log_record_json': {"username": token_request.username}})
    CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    try:
        with open(ADMIN_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_admin = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Arquivo de credenciais admin n‚àö¬£o encontrado: '{ADMIN_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": ADMIN_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais n‚àö¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro ao decodificar JSON do arquivo de credenciais: '{ADMIN_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": ADMIN_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais.")
    if token_request.username == usuario_admin["username"] and token_request.password == usuario_admin["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": token_request.username, "nivel_acesso": "admin"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"Ô£ø√º√Æ√´ Token JWT (ADMIN) gerado com sucesso para usu‚àö¬∞rio 'admin'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "admin", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "admin"}
    else:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Falha na autentica‚àö√ü‚àö¬£o (ADMIN) para usu‚àö¬∞rio '{token_request.username}'. Credenciais inv‚àö¬∞lidas.", extra={'log_record_json': {"username": token_request.username}})
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais de administrador incorretas.")
@app.post("/token_tester", tags=["autentica‚àö√ü‚àö¬£o_segura_tester"], response_model=TokenResponse, summary="Gera token JWT seguro para TESTER (credenciais 'tester/tester')")
async def gerar_token_seguro_tester(form_data: OAuth2PasswordRequestForm = Depends()):
    logger_app.info(f"Ô£ø√º√Æ√´ Requisi‚àö√ü‚àö¬£o para gerar token JWT (TESTER) recebida para usu‚àö¬∞rio: '{form_data.username}'", extra={'log_record_json': {"username": form_data.username}})
    CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")
    try:
        with open(TESTER_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_tester = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Arquivo de credenciais tester n‚àö¬£o encontrado: '{TESTER_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": TESTER_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais de tester n‚àö¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro ao decodificar JSON do arquivo de credenciais tester: '{TESTER_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": TESTER_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais de tester.")
    if form_data.username == usuario_tester["username"] and form_data.password == usuario_tester["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": form_data.username, "nivel_acesso": "tester"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"Ô£ø√º√Æ√´ Token JWT (TESTER) gerado com sucesso para usu‚àö¬∞rio 'tester'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "tester", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "tester"}
    else:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Requisi‚àö√ü‚àö¬£o para /token_tester com credenciais de tester inv‚àö¬∞lidas (IGNORADO para testes API).", extra={'log_record_json': {"username": form_data.username}})
        return {"access_token": "TOKEN_INVALIDO_PARA_TESTE", "token_type": "bearer", "nivel_acesso": "tester"}
@app.post("/somar", tags=["matem‚àö¬∞tica_segura"], summary="Soma um vetor de n‚àö‚à´meros inteiros (PROTEGIDO)", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=SomaResponse, response_class=JSONResponse)
async def somar_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)):
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu‚àö¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N‚àö‚â†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"‚Äö√ª¬∞√î‚àè√®  Requisi‚àö√ü‚àö¬£o POST em '/somar' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"Ô£ø√º√¨¬∂ Corpo da requisi‚àö√ü‚àö¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_soma = instancia_numeros.sum_numbers(lista_numeros)
        conteudo_resposta = {"resultado": resultado_soma, "mensagem": "Opera‚àö√ü‚àö¬£o de soma bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"‚Äö√ª√Ø Opera‚àö√ü‚àö¬£o de soma bem-sucedida. Resultado: {resultado_soma} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_soma": resultado_soma, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de valida‚àö√ü‚àö¬£o nos dados de entrada para '/somar': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Erro de tipo de dados na biblioteca calc_numbers para '/somar': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Exce‚àö√ü‚àö¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de Valida‚àö√ü‚àö¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro Cr‚àö‚â†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})
@app.post("/calcular_media", tags=["matem‚àö¬∞tica_segura"], summary="Calcula a m‚àö¬©dia de um vetor de n‚àö‚à´meros inteiros (PROTEGIDO)", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=MediaResponse, response_class=JSONResponse)
async def calcular_media_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)):
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu‚àö¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N‚àö‚â†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"‚Äö√ª¬∞√î‚àè√®  Requisi‚àö√ü‚àö¬£o POST em '/calcular_media' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"Ô£ø√º√¨¬∂ Corpo da requisi‚àö√ü‚àö¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_media = instancia_numeros.calculate_average(lista_numeros)
        if resultado_media is None:
            return {"media": None, "mensagem": "Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida para lista vazia", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        conteudo_resposta = {"media": resultado_media, "mensagem": "Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"‚Äö√ª√≥ Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida. M‚àö¬©dia: {resultado_media} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_media": resultado_media, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de valida‚àö√ü‚àö¬£o nos dados de entrada para '/calcular_media': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Erro de tipo de dados na biblioteca calc_numbers para '/calcular_media': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Exce‚àö√ü‚àö¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de Valida‚àö√ü‚àö¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro Cr‚àö‚â†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})
@app.get("/saude", tags=["sistema_seguro"], summary="Endpoint para verificar a sa‚àö‚à´de da API (P‚àö√∂BLICO)", response_class=JSONResponse, response_model=SaudeResponse)
async def verificar_saude_segura():
    timestamp = datetime.now().isoformat()
    saude_template = {
        "status": "OK",
        "version": "0.9.3",
        "ambiente": os.environ.get("API_ENVIRONMENT", "Desenvolvimento"),
        "timestamp": timestamp,
        "mensagem": "API Matem‚àö¬∞tica Segura est‚àö¬∞ operacional e respondendo.",
        "detalhes": {
            "servidor": "FastAPI",
            "seguranca": "JWT, HTTPS, Rate Limiting",
            "logs": "Detalhado em JSON"
        },
        "status_code": 200,
        "emoji_status": "Ô£ø√º√∂√Ñ",
        "indicador_saude": "Ô£ø√º√≠√∂ ‚àö√¨timo"
    }
    return saude_template
if __name__ == "__main__":
    import uvicorn
    CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
    os.makedirs(CREDENTIALS_DIR, exist_ok=True)
    CERT_FILE = os.path.join(CREDENTIALS_DIR, "certificado.pem")
    KEY_FILE = os.path.join(CREDENTIALS_DIR, "chave.pem")
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")
    if not os.path.exists(CERT_FILE) or not os.path.exists(KEY_FILE):
        logger_app.info("Ô£ø√º√Æ√´ Gerando certificados autoassinados para HTTPS...", extra={'log_record_json': {"acao": "geracao_certificados_https"}})
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())
        subject = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, "localhost")])
        builder = x509.CertificateBuilder().subject_name(subject).issuer_name(subject).public_key(private_key.public_key()).serial_number(x509.random_serial_number()).not_valid_before(datetime.utcnow()).not_valid_after(datetime.utcnow() + timedelta(days=365)).add_extension(x509.SubjectAlternativeName([x509.DNSName("localhost")]), critical=False)
        certificate = builder.sign(private_key, hashes.SHA256(), default_backend())
        with open(KEY_FILE, "wb") as key_f:
            key_f.write(private_key.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption()))
        with open(CERT_FILE, "wb") as cert_f:
            cert_f.write(certificate.public_bytes(serialization.Encoding.PEM))
        logger_app.info(f"Ô£ø√º√Æ√´ Certificados autoassinados gerados e salvos em: '{CREDENTIALS_DIR}/'", extra={'log_record_json': {"acao": "certificados_salvos", "diretorio": CREDENTIALS_DIR}})
    else:
        logger_app.info(f"Ô£ø√º√Æ√´ Certificados HTTPS autoassinados j‚àö¬∞ existentes em: '{CREDENTIALS_DIR}/'. Usando existentes.", extra={'log_record_json': {"acao": "certificados_existentes", "diretorio": CREDENTIALS_DIR}})
    if not os.path.exists(ADMIN_CREDENTIALS_FILE):
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Criando arquivo de credenciais admin padr‚àö¬£o: '{ADMIN_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_admin", "arquivo": ADMIN_CREDENTIALS_FILE}})
        admin_creds = {"username": "admin", "password": "admin"}
        with open(ADMIN_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(admin_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais admin padr‚àö¬£o criado.", extra={'log_record_json': {"acao": "creds_admin_criadas_sucesso", "arquivo": ADMIN_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais admin j‚àö¬∞ existente: '{ADMIN_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_admin_existentes", "arquivo": ADMIN_CREDENTIALS_FILE}})
    if not os.path.exists(TESTER_CREDENTIALS_FILE):
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Criando arquivo de credenciais tester padr‚àö¬£o: '{TESTER_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_tester", "arquivo": TESTER_CREDENTIALS_FILE}})
        tester_creds = {"username": "tester", "password": "tester"}
        with open(TESTER_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(tester_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais tester padr‚àö¬£o criado.", extra={'log_record_json': {"acao": "creds_tester_criadas_sucesso", "arquivo": TESTER_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais tester j‚àö¬∞ existente: '{TESTER_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_tester_existentes", "arquivo": TESTER_CREDENTIALS_FILE}})
    uvicorn.run(app, host="0.0.0.0", port=8882, ssl_certfile=CERT_FILE, ssl_keyfile=KEY_FILE)
üìÑ Arquivo: .\app\API-main-server-prod.py
  Tamanho: 0.03 MB (27.37 KB, 28030 bytes)
  N√∫mero de Linhas: 383

  C√≥digo Fonte:
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import logging
import json
from datetime import datetime, timedelta
from typing import List, Optional, Any
from fastapi import FastAPI, Request, HTTPException, Depends, status
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, ValidationError
from jose import JWTError, jwt
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from bibliotecas.calc_numbers import Numbers

# ‚Äö√∂√¥√î‚àè√® Configura‚àö√ü‚àö¬µes da API (vari‚àö¬∞veis de ambiente ou valores padr‚àö¬£o)
SECRET_KEY = os.environ.get("API_SECRET_KEY", "Jump@d2025!!(SegredoSuperSeguroParaTesteAPI)")
ALGORITHM = os.environ.get("API_JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.environ.get("API_TOKEN_EXPIRY_MINUTES", "30"))
RATE_LIMIT_REQUESTS_PER_MINUTE = int(os.environ.get("API_RATE_LIMIT", "200"))
DIRETORIO_LOGS = os.environ.get("API_LOG_DIR", "logs")
CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
origins_permitidas = os.environ.get("API_CORS_ORIGINS", "http://localhost").split(",")

# Ô£ø√º√Æ√´ Esquemas de seguran‚àö√üa OAuth2 para tokens JWT
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token_admin") # Ô£ø√º√µ¬∞√î‚àè√® Define esquema de seguran‚àö√üa para token de admin
oauth2_scheme_tester = OAuth2PasswordBearer(tokenUrl="token_tester") # Ô£ø√º√µ¬∞√î‚àè√® Define esquema de seguran‚àö√üa para token de tester

# Ô£ø√º‚Ñ¢¬µ Configura‚àö√ü‚àö¬£o de Logging (logs coloridos no console e logs JSON em arquivos)
if not os.path.exists(DIRETORIO_LOGS):
    os.makedirs(DIRETORIO_LOGS)
ARQUIVO_LOG_API = os.path.join(DIRETORIO_LOGS, "api-logs.json")
ARQUIVO_LOG_DETALHADO_API = os.path.join(DIRETORIO_LOGS, "api-detailed-logs.json")

class FormatterColoridoSeguro(logging.Formatter): # ‚Äö√∫¬Æ Formatter para logs coloridos no console
    CORES = {
        'DEBUG': '\033[94m',    'INFO': '\033[92m',     'WARNING': '\033[93m',
        'ERROR': '\033[91m',    'CRITICAL': '\033[97;41m', 'RESET': '\033[0m'
    }
    EMOJIS = {
        'DEBUG': 'Ô£ø√º√™√µ', 'INFO': '‚Äö√∫√ñ', 'WARNING': '‚Äö√∂‚Ä†√î‚àè√®', 'ERROR': 'Ô£ø√º√Æ‚Ä¢', 'CRITICAL': 'Ô£ø√º√∂¬Æ'
    }
    def format(self, record):
        cor_log = self.CORES.get(record.levelname, self.CORES['INFO'])
        reset_cor = self.CORES['RESET']
        emoji = self.EMOJIS.get(record.levelname, '')
        nivel_log = f"{cor_log}{record.levelname}{reset_cor}"
        mensagem = f"{cor_log}{record.getMessage()}{reset_cor}"
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"{timestamp} - {emoji} {nivel_log} - {record.name}:{record.lineno} - {mensagem}"

console_handler = logging.StreamHandler() # ‚Äö√∫√ß√î‚àè√® Handler para logs no console
console_handler.setFormatter(FormatterColoridoSeguro())
api_log_handler = logging.FileHandler(ARQUIVO_LOG_API, encoding='utf-8') # ‚Äö√∫√ß√î‚àè√® Handler para logs JSON resumidos
api_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s", "detalhes": %(log_record_json)s}')
api_log_handler.setFormatter(api_log_formatter)
api_detailed_log_handler = logging.FileHandler(ARQUIVO_LOG_DETALHADO_API, encoding='utf-8') # ‚Äö√∫√ß√î‚àè√® Handler para logs JSON detalhados
api_detailed_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "name": "%(name)s", "line": "%(lineno)d", "message": "%(message)s", "record": %(log_record_json)s}')
api_detailed_log_handler.setFormatter(api_detailed_log_formatter)

logger_app = logging.getLogger("api_server") # Ô£ø√º‚Ñ¢¬µ Logger principal da aplica‚àö√ü‚àö¬£o
logger_app.setLevel(logging.DEBUG)
logger_app.addHandler(console_handler)
logger_app.addHandler(api_log_handler)
logger_app.addHandler(api_detailed_log_handler)

# Ô£ø√º√∂√Ñ Inicializa‚àö√ü‚àö¬£o da Aplica‚àö√ü‚àö¬£o FastAPI
app = FastAPI(
    title="API Matem‚àö¬∞tica Segura",
    description="API RESTful para opera‚àö√ü‚àö¬µes de soma e m‚àö¬©dia - SEGURA (N‚àö‚â†vel M‚àö¬∞ximo) com autentica‚àö√ü‚àö¬£o JWT e HTTPS.",
    version="0.9.3"
)

# ‚Äö√ú√Æ√î‚àè√® Configura‚àö√ü‚àö¬£o de CORS (Cross-Origin Resource Sharing) - Ajuste 'origins_permitidas' conforme necess‚àö¬∞rio
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins_permitidas,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Ô£ø√º√µ¬∞√î‚àè√® Modelos de Dados (Pydantic) para Valida‚àö√ü‚àö¬£o e Documenta‚àö√ü‚àö¬£o Autom‚àö¬∞tica

class NumerosEntrada(BaseModel): # Modelo para lista de n‚àö‚à´meros na requisi‚àö√ü‚àö¬£o
    numeros: List[int]
    model_config = {
        "json_schema_extra": {
            "examples": [
                {"numeros": [1, 2, 3, 4]} # Exemplo para documenta‚àö√ü‚àö¬£o Swagger/ReDoc
            ]
        }
    }

class TokenRequest(BaseModel): # Modelo para requisi‚àö√ü‚àö¬£o de token
    username: str
    password: str

class TokenResponse(BaseModel): # Modelo para resposta de token JWT
    access_token: str
    token_type: str
    nivel_acesso: str
    model_config = {
        "json_schema_extra": {
            "examples": [
                {"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "token_type": "bearer", "nivel_acesso": "admin"} # Exemplo token
            ]
        }
    }

class SomaResponse(BaseModel): # Modelo para resposta da rota /somar
    resultado: int
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"resultado": 10, "mensagem": "Opera‚àö√ü‚àö¬£o de soma bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"} # Exemplo soma
            ]
        }

class MediaResponse(BaseModel): # Modelo para resposta da rota /calcular_media
    media: Optional[float] = None
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"media": 2.5, "mensagem": "Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"} # Exemplo m‚àö¬©dia
            ]
        }

class SaudeResponse(BaseModel): # Modelo para resposta da rota /saude
    status: str
    mensagem: str
    class Config:
        json_schema_extra = {
            "examples": [
                {"status": "OK", "mensagem": "API est‚àö¬∞ saud‚àö¬∞vel e SEGURA"} # Exemplo sa‚àö‚à´de
            ]
        }

class ErrorResponse(BaseModel): # Modelo para respostas de erro
    erro: str
    detalhes: Any
    class Config:
        json_schema_extra = {
            "examples": [
                {"erro": "Erro de valida‚àö√ü‚àö¬£o nos dados de entrada", "detalhes": "A lista de n‚àö‚à´meros n‚àö¬£o pode estar vazia."} # Exemplo erro
            ]
        }

# Ô£ø√º√Æ√´ Fun‚àö√ü‚àö¬µes de Seguran‚àö√üa (JWT - JSON Web Tokens)

def gerar_token_jwt(data: dict, expires_delta: Optional[timedelta] = None) -> str: # Ô£ø√º√Æ√´ Gera token JWT
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
        to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verificar_token_jwt(token: str) -> Optional[dict]: # ‚Äö√∫√ñ Verifica e decodifica token JWT
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None

async def obter_usuario_atual_jwt(token: str = Depends(oauth2_scheme)) -> dict: # Ô£ø√º√µ¬∞√î‚àè√® Depend‚àö‚Ñ¢ncia para obter usu‚àö¬∞rio ADMIN atual via JWT
    logger_app.debug(f"Ô£ø√º√Æ√≠ Validando Token JWT (ADMIN): {token[:10]}...", extra={'log_record_json': {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("‚Äö√∂‚Ä†√î‚àè√® Token JWT inv‚àö¬∞lido ou expirado (ADMIN). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_admin"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv‚àö¬∞lidas. Token JWT ausente, inv‚àö¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload

async def obter_usuario_tester_jwt(token: str = Depends(oauth2_scheme_tester)) -> dict: # Ô£ø√º√µ¬∞√î‚àè√® Depend‚àö‚Ñ¢ncia para obter usu‚àö¬∞rio TESTER atual via JWT
    logger_app.debug(f"Ô£ø√º√Æ√≠ Validando Token JWT (TESTER): {token[:10]}...", extra={'log_record_json':  {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("‚Äö√∂‚Ä†√î‚àè√® Token JWT inv‚àö¬∞lido ou expirado (TESTER). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_tester"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv‚àö¬∞lidas. Token JWT de tester ausente, inv‚àö¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload

# Ô£ø√º√Æ√´ Endpoints de Autentica‚àö√ü‚àö¬£o Segura (JWT)

@app.post("/token_admin", tags=["autentica‚àö√ü‚àö¬£o_segura"], response_model=TokenResponse, summary="Gera token JWT seguro para Administradores", description="Endpoint para gerar um token JWT de acesso com n‚àö‚â†vel 'admin'. Requer credenciais de administrador.")
async def gerar_token_admin_seguro(token_request: TokenRequest): # Ô£ø√º√Æ√´ Rota para gerar token JWT de ADMIN
    logger_app.info(f"Ô£ø√º√Æ√´ Requisi‚àö√ü‚àö¬£o para gerar token JWT (ADMIN) recebida para usu‚àö¬∞rio: '{token_request.username}'", extra={'log_record_json': {"username": token_request.username}})
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    try:
        with open(ADMIN_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_admin = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Arquivo de credenciais admin n‚àö¬£o encontrado: '{ADMIN_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": ADMIN_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais n‚àö¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro ao decodificar JSON do arquivo de credenciais: '{ADMIN_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": ADMIN_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais.")
    if token_request.username == usuario_admin["username"] and token_request.password == usuario_admin["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": token_request.username, "nivel_acesso": "admin"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"Ô£ø√º√Æ√´ Token JWT (ADMIN) gerado com sucesso para usu‚àö¬∞rio 'admin'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "admin", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "admin"}
    else:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Falha na autentica‚àö√ü‚àö¬£o (ADMIN) para usu‚àö¬∞rio '{token_request.username}'. Credenciais inv‚àö¬∞lidas.", extra={'log_record_json': {"username": token_request.username}})
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais de administrador incorretas.")

@app.post("/token_tester", tags=["autentica‚àö√ü‚àö¬£o_segura_tester"], response_model=TokenResponse, summary="Gera token JWT seguro para Testers", description="Endpoint para gerar um token JWT de acesso com n‚àö‚â†vel 'tester'. Requer credenciais de tester.")
async def gerar_token_seguro_tester(form_data: OAuth2PasswordRequestForm = Depends()): # Ô£ø√º√Æ√´ Rota para gerar token JWT de TESTER
    logger_app.info(f"Ô£ø√º√Æ√´ Requisi‚àö√ü‚àö¬£o para gerar token JWT (TESTER) recebida para usu‚àö¬∞rio: '{form_data.username}'", extra={'log_record_json': {"username": form_data.username}})
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")
    try:
        with open(TESTER_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_tester = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Arquivo de credenciais tester n‚àö¬£o encontrado: '{TESTER_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": TESTER_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais de tester n‚àö¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro ao decodificar JSON do arquivo de credenciais tester: '{TESTER_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": TESTER_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais de tester.")
    if form_data.username == usuario_tester["username"] and form_data.password == usuario_tester["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": form_data.username, "nivel_acesso": "tester"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"Ô£ø√º√Æ√´ Token JWT (TESTER) gerado com sucesso para usu‚àö¬∞rio 'tester'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "tester", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "tester"}
    else:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Requisi‚àö√ü‚àö¬£o para /token_tester com credenciais de tester inv‚àö¬∞lidas (IGNORADO para testes API).", extra={'log_record_json': {"username": form_data.username}})
        return {"access_token": "TOKEN_INVALIDO_PARA_TESTE", "token_type": "bearer", "nivel_acesso": "tester"}

# ‚Äö√ª√Ø Endpoints de Opera‚àö√ü‚àö¬µes Matem‚àö¬∞ticas (PROTEGIDOS por JWT)

@app.post("/somar", tags=["matem‚àö¬∞tica_segura"], summary="Soma um vetor de n‚àö‚à´meros inteiros", description="Endpoint PROTEGIDO que realiza a soma de uma lista de n‚àö‚à´meros inteiros fornecida no corpo da requisi‚àö√ü‚àö¬£o. Requer token JWT de administrador v‚àö¬∞lido.", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=SomaResponse, response_class=JSONResponse)
async def somar_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)): # ‚Äö√ª√Ø Rota para somar vetor (PROTEGIDA)
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu‚àö¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N‚àö‚â†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"‚Äö√ª¬∞√î‚àè√®  Requisi‚àö√ü‚àö¬£o POST em '/somar' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"Ô£ø√º√¨¬∂ Corpo da requisi‚àö√ü‚àö¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_soma = instancia_numeros.sum_numbers(lista_numeros)
        conteudo_resposta = {"resultado": resultado_soma, "mensagem": "Opera‚àö√ü‚àö¬£o de soma bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"‚Äö√ª√Ø Opera‚àö√ü‚àö¬£o de soma bem-sucedida. Resultado: {resultado_soma} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_soma": resultado_soma, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de valida‚àö√ü‚àö¬£o nos dados de entrada para '/somar': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Erro de tipo de dados na biblioteca calc_numbers para '/somar': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Exce‚àö√ü‚àö¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de Valida‚àö√ü‚àö¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro Cr‚àö‚â†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})

@app.post("/calcular_media", tags=["matem‚àö¬∞tica_segura"], summary="Calcula a m‚àö¬©dia de um vetor de n‚àö‚à´meros inteiros", description="Endpoint PROTEGIDO que calcula a m‚àö¬©dia de uma lista de n‚àö‚à´meros inteiros fornecida. Requer token JWT de administrador v‚àö¬∞lido.", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=MediaResponse, response_class=JSONResponse)
async def calcular_media_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)): # ‚Äö√ª√≥ Rota para calcular m‚àö¬©dia vetor (PROTEGIDA)
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu‚àö¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N‚àö‚â†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"‚Äö√ª¬∞√î‚àè√®  Requisi‚àö√ü‚àö¬£o POST em '/calcular_media' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"Ô£ø√º√¨¬∂ Corpo da requisi‚àö√ü‚àö¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_media = instancia_numeros.calculate_average(lista_numeros)
        if resultado_media is None:
            return {"media": None, "mensagem": "Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida para lista vazia", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        conteudo_resposta = {"media": resultado_media, "mensagem": "Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"‚Äö√ª√≥ Opera‚àö√ü‚àö¬£o de m‚àö¬©dia bem-sucedida. M‚àö¬©dia: {resultado_media} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_media": resultado_media, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de valida‚àö√ü‚àö¬£o nos dados de entrada para '/calcular_media': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Erro de tipo de dados na biblioteca calc_numbers para '/calcular_media': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"Ô£ø√º√Æ‚Ä¢ Exce‚àö√ü‚àö¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"‚Äö√∂‚Ä†√î‚àè√® Erro de Valida‚àö√ü‚àö¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"Ô£ø√º√≠‚Ä¢ Erro Cr‚àö‚â†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})

# Ô£ø√º¬©‚à´ Endpoint de Sa‚àö‚à´de da API (P‚àö√∂BLICO - Sem Autentica‚àö√ü‚àö¬£o)

@app.get("/saude", tags=["sistema_seguro"], summary="Verifica a sa‚àö‚à´de da API", description="Endpoint P‚àö√∂BLICO para verificar se a API est‚àö¬∞ online e funcionando corretamente.", response_class=JSONResponse, response_model=SaudeResponse)
async def verificar_saude_segura(): # Ô£ø√º¬©‚à´ Rota de sa‚àö‚à´de da API (P‚àö√∂BLICA)
    timestamp = datetime.now().isoformat()
    saude_template = {
        "status": "OK",
        "version": "0.9.3",
        "ambiente": os.environ.get("API_ENVIRONMENT", "Desenvolvimento"),
        "timestamp": timestamp,
        "mensagem": "API Matem‚àö¬∞tica Segura est‚àö¬∞ operacional e respondendo.",
        "detalhes": {
            "servidor": "FastAPI",
            "seguranca": "JWT, HTTPS, Rate Limiting",
            "logs": "Detalhado em JSON"
        },
        "status_code": 200,
        "emoji_status": "Ô£ø√º√∂√Ñ",
        "indicador_saude": "Ô£ø√º√≠√∂ ‚àö√¨timo"
    }
    return saude_template

# ‚Äö√∂√¥√î‚àè√® Execu‚àö√ü‚àö¬£o do Servidor Uvicorn (HTTPS)
if __name__ == "__main__":
    import uvicorn

    # Ô£ø√º√Æ√´ Cria diret‚àö‚â•rio para credenciais e certificados se n‚àö¬£o existirem
    os.makedirs(CREDENTIALS_DIR, exist_ok=True)
    CERT_FILE = os.path.join(CREDENTIALS_DIR, "certificado.pem")
    KEY_FILE = os.path.join(CREDENTIALS_DIR, "chave.pem")
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")

    # Ô£ø√º√Æ√´ Gera certificados autoassinados HTTPS se n‚àö¬£o existirem
    if not os.path.exists(CERT_FILE) or not os.path.exists(KEY_FILE):
        logger_app.info("Ô£ø√º√Æ√´ Gerando certificados autoassinados para HTTPS...", extra={'log_record_json': {"acao": "geracao_certificados_https"}})
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())
        subject = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, "localhost")])
        builder = x509.CertificateBuilder().subject_name(subject).issuer_name(subject).public_key(private_key.public_key()).serial_number(x509.random_serial_number()).not_valid_before(datetime.utcnow()).not_valid_after(datetime.utcnow() + timedelta(days=365)).add_extension(x509.SubjectAlternativeName([x509.DNSName("localhost")]), critical=False)
        certificate = builder.sign(private_key, hashes.SHA256(), default_backend())
        with open(KEY_FILE, "wb") as key_f:
            key_f.write(private_key.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption()))
        with open(CERT_FILE, "wb") as cert_f:
            cert_f.write(certificate.public_bytes(serialization.Encoding.PEM))
        logger_app.info(f"Ô£ø√º√Æ√´ Certificados autoassinados gerados e salvos em: '{CREDENTIALS_DIR}/'", extra={'log_record_json': {"acao": "certificados_salvos", "diretorio": CREDENTIALS_DIR}})
    else:
        logger_app.info(f"Ô£ø√º√Æ√´ Certificados HTTPS autoassinados j‚àö¬∞ existentes em: '{CREDENTIALS_DIR}/'. Usando existentes.", extra={'log_record_json': {"acao": "certificados_existentes", "diretorio": CREDENTIALS_DIR}})

    # ‚Äö√∂√¥√î‚àè√® Cria arquivos de credenciais padr‚àö¬£o (admin/admin, tester/tester) se n‚àö¬£o existirem
    if not os.path.exists(ADMIN_CREDENTIALS_FILE):
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Criando arquivo de credenciais admin padr‚àö¬£o: '{ADMIN_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_admin", "arquivo": ADMIN_CREDENTIALS_FILE}})
        admin_creds = {"username": "admin", "password": "admin"}
        with open(ADMIN_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(admin_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais admin padr‚àö¬£o criado.", extra={'log_record_json': {"acao": "creds_admin_criadas_sucesso", "arquivo": ADMIN_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais admin j‚àö¬∞ existente: '{ADMIN_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_admin_existentes", "arquivo": ADMIN_CREDENTIALS_FILE}})

    if not os.path.exists(TESTER_CREDENTIALS_FILE):
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Criando arquivo de credenciais tester padr‚àö¬£o: '{TESTER_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_tester", "arquivo": TESTER_CREDENTIALS_FILE}})
        tester_creds = {"username": "tester", "password": "tester"}
        with open(TESTER_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(tester_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais tester padr‚àö¬£o criado.", extra={'log_record_json': {"acao": "creds_tester_criadas_sucesso", "arquivo": TESTER_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"‚Äö√∂√¥√î‚àè√®  Arquivo de credenciais tester j‚àö¬∞ existente: '{TESTER_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_tester_existentes", "arquivo": TESTER_CREDENTIALS_FILE}})

    # Ô£ø√º√∂√Ñ Inicia o servidor Uvicorn com HTTPS e documenta‚àö√ü‚àö¬£o Swagger/ReDoc AUTOM‚àö√ÖTICA no /docs e /redoc
    print("‚Äö√∫√ñ Servidor FastAPI inicializado. ")
    print("‚Äö√ª¬∞√î‚àè√®  Acesse a documenta‚àö√ü‚àö¬£o interativa Swagger UI em: http://localhost:8882/docs") # Ô£ø√º√¨√± Instru‚àö√ü‚àö¬µes Swagger UI
    print("‚Äö√ª¬∞√î‚àè√®  Acesse a documenta‚àö√ü‚àö¬£o alternativa ReDoc em: http://localhost:8882/redoc") # Ô£ø√º√¨√∂ Instru‚àö√ü‚àö¬µes ReDoc
    uvicorn.run(app, host="0.0.0.0", port=8882, ssl_certfile=CERT_FILE, ssl_keyfile=KEY_FILE)
üìÇ Pasta: .\bibliotecas\__pycache__

üìÑ Arquivo: .\bibliotecas\calc_numbers.py
  Tamanho: 0.00 MB (3.09 KB, 3160 bytes)
  N√∫mero de Linhas: 59

  C√≥digo Fonte:
class Numbers:
    def __init__(self):
        pass

    def sum_numbers(self, numeros: any) -> int:
        try:
            validated_list = self._validate_integer_list(numeros, operation_name="soma")
            if not validated_list:
                raise ValueError("Erro de valor na opera√ß√£o de soma: A lista de n√∫meros n√£o pode estar vazia.")
            return sum(validated_list)
        except (TypeError, ValueError) as e:
            raise e

    def calculate_average(self, numeros: any) -> float | None:
        try:
            validated_list = self._validate_integer_list(numeros, operation_name="m√©dia")
            if not validated_list:
                return None
            return sum(validated_list) / len(validated_list)
        except (TypeError, ValueError) as e:
            raise e

    def _validate_input_list(self, data: any, operation_name: str) -> list:
        if not isinstance(data, list):
            raise TypeError(f"Erro de tipo na opera√ß√£o de {operation_name}: A entrada deve ser uma lista, mas foi fornecido '{type(data).__name__}'.")
        if data is None:
            raise ValueError(f"Erro de valor na opera√ß√£o de {operation_name}: A lista de n√∫meros n√£o pode ser None.")
        if not data and operation_name == "soma":
            raise ValueError(f"Erro de valor na opera√ß√£o de {operation_name}: A lista de n√∫meros n√£o pode estar vazia.")
        if not data and operation_name == "m√©dia":
            return []
        return data

    def _validate_integer_list(self, data: any, operation_name: str) -> list[int]:
        try:
            validated_list = self._validate_input_list(data, operation_name)
        except (TypeError, ValueError) as e:
            raise e

        if not validated_list and operation_name == "m√©dia":
            return []

        integer_list = []
        for index, item in enumerate(validated_list):
            if item is None:
                raise ValueError(f"Erro de valor na opera√ß√£o de {operation_name}: Elemento na posi√ß√£o {index+1} n√£o pode ser None.")
            if isinstance(item, int):
                integer_list.append(item)
            elif isinstance(item, (float, str)):
                try:
                    integer_item = int(float(item))
                    if integer_item != float(item):
                        raise ValueError(f"Erro de valor na opera√ß√£o de {operation_name}: Elemento na posi√ß√£o {index+1} ('{item}') n√£o √© um inteiro v√°lido e a convers√£o resultaria em perda de informa√ß√£o. Forne√ßa apenas inteiros.")
                    integer_list.append(integer_item)
                except ValueError:
                    raise ValueError(f"Erro de valor na opera√ß√£o de {operation_name}: Elemento na posi√ß√£o {index+1} ('{item}') n√£o √© um inteiro v√°lido e n√£o pode ser convertido para inteiro.")
            else:
                raise ValueError(f"Erro de valor na opera√ß√£o de {operation_name}: Elemento na posi√ß√£o {index+1} ('{item}') n√£o √© um inteiro v√°lido. Tipo encontrado: '{type(item).__name__}'.")
        return integer_list
üìÑ Arquivo: .\bibliotecas\__pycache__\calc_numbers.cpython-310.pyc
  Tamanho: 0.00 MB (2.58 KB, 2642 bytes)
  N√∫mero de Linhas: 24
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\credentials\admin_credentials.json
  Tamanho: 0.00 MB (0.05 KB, 55 bytes)
  N√∫mero de Linhas: 4
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\credentials\certificado.pem
  Tamanho: 0.00 MB (1.01 KB, 1034 bytes)
  N√∫mero de Linhas: 18
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\credentials\chave.pem
  Tamanho: 0.00 MB (1.66 KB, 1704 bytes)
  N√∫mero de Linhas: 28
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\credentials\tester_credentials.json
  Tamanho: 0.00 MB (0.06 KB, 57 bytes)
  N√∫mero de Linhas: 4
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\docs\docproject.txt
  Tamanho: 0.06 MB (65.97 KB, 67549 bytes)
  N√∫mero de Linhas: 1024

  C√≥digo Fonte:
# Documenta√É¬ß√É¬£o do Projeto

Este documento foi gerado automaticamente pelo script `documentador_projeto.py`.

Data de Gera√É¬ß√É¬£o: 2025-03-10 00:32:48
Diret√É¬≥rio Raiz: D:\projeto jumpad

================================================================================

ƒü≈∏‚Äú‚Äö Pasta: .\app

ƒü≈∏‚Äú‚Äö Pasta: .\bibliotecas

ƒü≈∏‚Äú‚Äö Pasta: .\config

ƒü≈∏‚Äú‚Äö Pasta: .\credentials

ƒü≈∏‚Äú‚Äö Pasta: .\docs

ƒü≈∏‚Äú‚Äö Pasta: .\exceptions

ƒü≈∏‚Äú‚Äö Pasta: .\logs

ƒü≈∏‚Äú‚Äö Pasta: .\schemas

ƒü≈∏‚Äú‚Äö Pasta: .\tests

ƒü≈∏‚Äú‚Äö Pasta: .\test_logs

ƒü≈∏‚Äú‚Äû Arquivo: .\.gitignore
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√É¬∫mero de Linhas: 0
  Conte√É¬∫do n√É¬£o textual ou extens√É¬£o n√É¬£o suportada para visualiza√É¬ß√É¬£o do c√É¬≥digo fonte.

ƒü≈∏‚Äú‚Äû Arquivo: .\CHANGELOG.md
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√É¬∫mero de Linhas: 0

  C√É¬≥digo Fonte:

ƒü≈∏‚Äú‚Äû Arquivo: .\Dockerfile
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√É¬∫mero de Linhas: 0
  Conte√É¬∫do n√É¬£o textual ou extens√É¬£o n√É¬£o suportada para visualiza√É¬ß√É¬£o do c√É¬≥digo fonte.

ƒü≈∏‚Äú‚Äû Arquivo: .\doc_gen.py
  Tamanho: 0.00 MB (2.06 KB, 2108 bytes)
  N√É¬∫mero de Linhas: 42

  C√É¬≥digo Fonte:
import os
import datetime

def document_project_structure(start_path="."):
    docs_dir = os.path.join(start_path, "docs")
    doc_file_path = os.path.join(docs_dir, "project_structure.txt")

    if not os.path.exists(docs_dir):
        os.makedirs(docs_dir)
        print(f"Diret√É¬≥rio 'docs/' criado.")

    with open(doc_file_path, 'w', encoding='utf-8') as doc_file:
        doc_file.write("DOCUMENTA√É‚Ä°√É∆íO AUTOM√ÉTICA DA ESTRUTURA DO PROJETO\n")
        doc_file.write("---------------------------------------------------\n")
        doc_file.write(f"Gerado por: {os.path.basename(__file__)}\n")
        doc_file.write("Data de Gera√É¬ß√É¬£o: {:%d/%m/%Y %H:%M:%S}\n".format(datetime.datetime.now()))
        doc_file.write("Codifica√É¬ß√É¬£o do Arquivo: UTF-8\n")
        doc_file.write("\nEstrutura de diret√É¬≥rios e arquivos a partir da raiz do projeto:\n\n")

        for root, dirs, files in os.walk(start_path):
            depth = root.replace(start_path, '').count(os.sep)
            indent = '  ' * depth
            doc_file.write(f"{indent}{os.path.basename(root)}/\n")

            sub_indent = '  ' * (depth + 1)
            for filename in files:
                if filename != os.path.basename(__file__):
                    doc_file.write(f"{sub_indent}{filename}\n")

        doc_file.write("\n---------------------------------------------------\n")
        doc_file.write("Fim da Documenta√É¬ß√É¬£o da Estrutura do Projeto.\n")
        doc_file.write("\nEste arquivo foi gerado automaticamente. Para atualizar a documenta√É¬ß√É¬£o,\n")
        doc_file.write("execute o script novamente: 'python {}'\n".format(os.path.basename(__file__)))
        doc_file.write("Certifique-se de que seu editor de texto/visualizador utilize UTF-8 para exibir corretamente os caracteres.\n")

    print(f"\nDocumenta√É¬ß√É¬£o da estrutura do projeto gerada com sucesso em: '{doc_file_path}' (Codifica√É¬ß√É¬£o: UTF-8)")


if __name__ == "__main__":
    print("Gerando documenta√É¬ß√É¬£o da estrutura do projeto (UTF-8)...")
    document_project_structure()
    print("\nProcesso conclu√É¬≠do.")
ƒü≈∏‚Äú‚Äû Arquivo: .\doc_gen_full.py
  Tamanho: 0.01 MB (8.60 KB, 8805 bytes)
  N√É¬∫mero de Linhas: 192

  C√É¬≥digo Fonte:
import os
import sqlite3
import chardet
import datetime

# Define o nome da pasta 'docs' e o caminho completo para o arquivo de sa√¢ÀÜ≈°√¢‚Ä∞¬†da
DOCS_FOLDER = "docs"
OUTPUT_FILE = os.path.join(DOCS_FOLDER, "docproject.txt")
SAMPLE_SIZE = 3
LARGE_TABLE_THRESHOLD = 100

def detect_encoding(filepath):
    try:
        with open(filepath, 'rb') as f:
            rawdata = f.read()
            result = chardet.detect(rawdata)
            return result['encoding']
    except Exception:
        return 'utf-8'

def get_file_info(filepath):
    size_bytes = os.path.getsize(filepath)
    size_kb = size_bytes / 1024
    size_mb = size_kb / 1024

    line_count = 0
    try:
        encoding = detect_encoding(filepath)
        with open(filepath, 'r', encoding=encoding, errors='ignore') as f:
            for line in f:
                line_count += 1
    except Exception as e:
        print(f"Aviso: Erro ao contar linhas de '{filepath}': {e}")
        line_count = -1

    return {
        "tamanho_bytes": size_bytes,
        "tamanho_kb": f"{size_kb:.2f}",
        "tamanho_mb": f"{size_mb:.2f}",
        "numero_linhas": line_count
    }

def get_file_content_bruto(filepath):
    try:
        encoding = detect_encoding(filepath)
        with open(filepath, 'r', encoding=encoding, errors='ignore') as f:
            return f.read()
    except Exception as e:
        print(f"Aviso: Erro ao ler conte√¢ÀÜ≈°√¢ÀÜ¬´do de '{filepath}': {e}")
        return "[ERRO AO LER CONTE√¢ÀÜ≈°√É¬∂DO]"

def analyze_sqlite_db(filepath, doc_file):
    conn = None
    try:
        conn = sqlite3.connect(filepath)
        cursor = conn.cursor()

        doc_file.write("\n" + "="*80 + "\n")
        doc_file.write(f"  √Ø¬£¬ø√É¬º√É¬≠√É¬¶ Banco de Dados SQLite: {filepath}\n")
        doc_file.write("="*80 + "\n")

        db_size_bytes = os.path.getsize(filepath)
        db_size_kb = db_size_bytes / 1024
        db_size_mb = db_size_kb / 1024

        doc_file.write(f"  Tamanho: {db_size_mb:.2f} MB ({db_size_kb:.2f} KB, {db_size_bytes} bytes)\n")

        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()

        if tables:
            doc_file.write(f"\n  Tabelas:\n")
            for table_name_tuple in tables:
                table_name = table_name_tuple[0]
                doc_file.write(f"\n    √Ø¬£¬ø√É¬º√É¬≥√É‚Ä°√É‚Äù√¢ÀÜ√É¬® Tabela: {table_name}\n")

                cursor.execute(f"PRAGMA table_info('{table_name}')")
                columns_info = cursor.fetchall()
                if columns_info:
                    doc_file.write(f"    Colunas:\n")
                    doc_file.write("    " + "-"*74 + "\n")
                    doc_file.write(f"    | {'ID':<4} | {'Nome':<20} | {'Tipo':<15} | {'N√¢ÀÜ≈°√Ç¬£o Nulo?':<10} | {'Padr√¢ÀÜ≈°√Ç¬£o':<10} | {'PK':<3} |\n")
                    doc_file.write("    " + "-"*74 + "\n")

                    for col_info in columns_info:
                        cid, name, type_str, notnull, dflt_value, pk = col_info
                        doc_file.write(f"    | {cid:<4} | {name:<20} | {type_str:<15} | {'Sim' if notnull else 'N√¢ÀÜ≈°√Ç¬£o':<10} | {str(dflt_value):<10} | {'Sim' if pk else 'N√¢ÀÜ≈°√Ç¬£o':<3} |\n")
                    doc_file.write("    " + "-"*74 + "\n")


                cursor.execute(f"SELECT COUNT(*) FROM '{table_name}'")
                row_count = cursor.fetchone()[0]
                doc_file.write(f"    N√¢ÀÜ≈°√¢ÀÜ¬´mero de Registros: {row_count}\n")

                if row_count > 0:
                    doc_file.write(f"    Amostra de Dados:\n")

                    doc_file.write(f"      Topo ({SAMPLE_SIZE} registros):\n")
                    cursor.execute(f"SELECT * FROM '{table_name}' LIMIT {SAMPLE_SIZE}")
                    top_rows = cursor.fetchall()
                    if top_rows:
                        header_row = [col_info[1] for col_info in columns_info]
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                        doc_file.write("      | " + " | ".join([f'{header:<20}' for header in header_row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")

                        for row in top_rows:
                            doc_file.write("      | " + " | ".join([f'{str(item):<20}' for item in row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")


                    doc_file.write(f"      Fundo ({SAMPLE_SIZE} registros):\n")
                    cursor.execute(f"SELECT * FROM '{table_name}' ORDER BY ROWID DESC LIMIT {SAMPLE_SIZE}")
                    bottom_rows = cursor.fetchall()
                    if bottom_rows:
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                        doc_file.write("      | " + " | ".join([f'{header:<20}' for header in header_row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                        for row in bottom_rows:
                            doc_file.write("      | " + " | ".join([f'{str(item):<20}' for item in row]) + " |\n")
                        doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")

                    if row_count > LARGE_TABLE_THRESHOLD:
                        doc_file.write(f"      Meio ({SAMPLE_SIZE} registros):\n")
                        offset = row_count // 2 - (SAMPLE_SIZE // 2) if row_count > SAMPLE_SIZE else 0
                        if offset < 0: offset = 0
                        cursor.execute(f"SELECT * FROM '{table_name}' LIMIT {SAMPLE_SIZE} OFFSET {offset}")
                        middle_rows = cursor.fetchall()
                        if middle_rows:
                            doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                            doc_file.write("      | " + " | ".join([f'{header:<20}' for header in header_row]) + " |\n")
                            doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")
                            for row in middle_rows:
                                doc_file.write("      | " + " | ".join([f'{str(item):<20}' for item in row]) + " |\n")
                            doc_file.write("      " + "-"*(len(header_row) * 22 + 6) + "\n")


        else:
            doc_file.write(f"  Nenhuma tabela encontrada neste banco de dados.\n")


    except sqlite3.Error as e:
        doc_file.write(f"Erro ao analisar banco de dados SQLite '{filepath}': {e}\n")
    finally:
        if conn:
            conn.close()

def main():
    root_dir = "."
    print("√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬® Iniciando An√¢ÀÜ≈°√Ç¬∞lise do Projeto √¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®")

    # Cria a pasta 'docs' se ela n√¢ÀÜ≈°√Ç¬£o existir
    if not os.path.exists(DOCS_FOLDER):
        os.makedirs(DOCS_FOLDER)

    with open(OUTPUT_FILE, 'w', encoding='utf-8') as doc_file:
        doc_file.write(f"# Documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o do Projeto\n\n")
        doc_file.write(f"Este documento foi gerado automaticamente pelo script `documentador_projeto.py`.\n\n")
        doc_file.write(f"Data de Gera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        doc_file.write(f"Diret√¢ÀÜ≈°√¢‚Ä∞¬•rio Raiz: {os.path.abspath(root_dir)}\n\n")
        doc_file.write("="*80 + "\n")

        for root, dirs, files in os.walk(root_dir):
            for dir_name in dirs:
                folder_path = os.path.join(root, dir_name)
                doc_file.write(f"\n√Ø¬£¬ø√É¬º√É¬¨√É‚Ä° Pasta: {folder_path}\n")

            for file_name in files:
                filepath = os.path.join(root, file_name)
                file_ext = file_name.lower().split('.')[-1]

                doc_file.write(f"\n√Ø¬£¬ø√É¬º√É¬¨√É‚Äò Arquivo: {filepath}\n")

                file_info = get_file_info(filepath)
                doc_file.write(f"  Tamanho: {file_info['tamanho_mb']} MB ({file_info['tamanho_kb']} KB, {file_info['tamanho_bytes']} bytes)\n")
                doc_file.write(f"  N√¢ÀÜ≈°√¢ÀÜ¬´mero de Linhas: {file_info['numero_linhas']}\n")

                if file_ext in ('py', 'txt', 'js', 'html', 'css', 'java', 'c', 'cpp', 'h', 'sh', 'sql', 'md'):
                    doc_file.write(f"\n  C√¢ÀÜ≈°√¢‚Ä∞¬•digo Fonte:\n")
                    code_content = get_file_content_bruto(filepath)
                    doc_file.write(code_content)
                else:
                    doc_file.write(f"  Conte√¢ÀÜ≈°√¢ÀÜ¬´do n√¢ÀÜ≈°√Ç¬£o textual ou extens√¢ÀÜ≈°√Ç¬£o n√¢ÀÜ≈°√Ç¬£o suportada para visualiza√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o do c√¢ÀÜ≈°√¢‚Ä∞¬•digo fonte.\n")

                if file_ext in ('db', 'sqlite', 'sqlite3'):
                    analyze_sqlite_db(filepath, doc_file)

    print("√¢‚Ç¨≈°√É¬∫√É‚Äì Documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o Gerada com Sucesso! √¢‚Ç¨≈°√É¬∫√É‚Äì")
    print(f"Arquivo de documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o salvo em: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
ƒü≈∏‚Äú‚Äû Arquivo: .\README.md
  Tamanho: 0.00 MB (0.00 KB, 0 bytes)
  N√É¬∫mero de Linhas: 0

  C√É¬≥digo Fonte:

ƒü≈∏‚Äú‚Äû Arquivo: .\requirements.txt
  Tamanho: 0.00 MB (0.16 KB, 167 bytes)
  N√É¬∫mero de Linhas: 10

  C√É¬≥digo Fonte:
fastapi
uvicorn
python-jose[cryptography]  
cryptography              
requests
pytest
colorama
python-dotenv             
pydantic                  
inquirer
ƒü≈∏‚Äú‚Äû Arquivo: .\app\API-main-server-mvp.py
  Tamanho: 0.02 MB (24.25 KB, 24831 bytes)
  N√É¬∫mero de Linhas: 321

  C√É¬≥digo Fonte:
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import logging
import json
from datetime import datetime, timedelta
from typing import List, Optional, Any
from fastapi import FastAPI, Request, HTTPException, Depends, status
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, ValidationError
from jose import JWTError, jwt
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from bibliotecas.calc_numbers import Numbers
SECRET_KEY = os.environ.get("API_SECRET_KEY", "Jump@d2025!!(SegredoSuperSeguroParaTesteAPI)")
ALGORITHM = os.environ.get("API_JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.environ.get("API_TOKEN_EXPIRY_MINUTES", "30"))
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token_admin")
oauth2_scheme_tester = OAuth2PasswordBearer(tokenUrl="token_tester")
RATE_LIMIT_REQUESTS_PER_MINUTE = int(os.environ.get("API_RATE_LIMIT", "200"))
RATE_LIMIT_STORAGE = {}
DIRETORIO_LOGS = os.environ.get("API_LOG_DIR", "logs")
if not os.path.exists(DIRETORIO_LOGS):
    os.makedirs(DIRETORIO_LOGS)
ARQUIVO_LOG_API = os.path.join(DIRETORIO_LOGS, "api-logs.json")
ARQUIVO_LOG_DETALHADO_API = os.path.join(DIRETORIO_LOGS, "api-detailed-logs.json")
class FormatterColoridoSeguro(logging.Formatter):
    CORES = {
        'DEBUG': '\033[94m',    'INFO': '\033[92m',     'WARNING': '\033[93m',
        'ERROR': '\033[91m',    'CRITICAL': '\033[97;41m', 'RESET': '\033[0m'
    }
    EMOJIS = {
        'DEBUG': '√Ø¬£¬ø√É¬º√É¬™√É¬µ', 'INFO': '√¢‚Ç¨≈°√É¬∫√É‚Äì', 'WARNING': '√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬®', 'ERROR': '√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢', 'CRITICAL': '√Ø¬£¬ø√É¬º√É¬∂√Ç¬Æ'
    }
    def format(self, record):
        cor_log = self.CORES.get(record.levelname, self.CORES['INFO'])
        reset_cor = self.CORES['RESET']
        emoji = self.EMOJIS.get(record.levelname, '')
        nivel_log = f"{cor_log}{record.levelname}{reset_cor}"
        mensagem = f"{cor_log}{record.getMessage()}{reset_cor}"
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"{timestamp} - {emoji} {nivel_log} - {record.name}:{record.lineno} - {mensagem}"
console_handler = logging.StreamHandler()
console_handler.setFormatter(FormatterColoridoSeguro())
api_log_handler = logging.FileHandler(ARQUIVO_LOG_API, encoding='utf-8')
api_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s", "detalhes": %(log_record_json)s}')
api_log_handler.setFormatter(api_log_formatter)
api_detailed_log_handler = logging.FileHandler(ARQUIVO_LOG_DETALHADO_API, encoding='utf-8')
api_detailed_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "name": "%(name)s", "line": "%(lineno)d", "message": "%(message)s", "record": %(log_record_json)s}')
api_detailed_log_handler.setFormatter(api_detailed_log_formatter)
logger_app = logging.getLogger("api_server")
logger_app.setLevel(logging.DEBUG)
logger_app.addHandler(console_handler)
logger_app.addHandler(api_log_handler)
logger_app.addHandler(api_detailed_log_handler)
app = FastAPI(title="API Matem√¢ÀÜ≈°√Ç¬∞tica Segura", description="API RESTful para opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬µes de soma e m√¢ÀÜ≈°√Ç¬©dia - SEGURA (N√¢ÀÜ≈°√¢‚Ä∞¬†vel M√¢ÀÜ≈°√Ç¬∞ximo)", version="0.9.3", default_response_class=JSONResponse)
origins_permitidas = os.environ.get("API_CORS_ORIGINS", "http://localhost").split(",")
class NumerosEntrada(BaseModel):
    numeros: List[int]
    model_config = {
        "json_schema_extra": {
            "examples": [
                {"numeros": [1, 2, 3, 4]}
            ]
        }
    }
class TokenRequest(BaseModel):
    username: str
    password: str
class SomaResponse(BaseModel):
    resultado: int
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"resultado": 10, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de soma bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"}
            ]
        }
class MediaResponse(BaseModel):
    media: Optional[float] = None
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"media": 2.5, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"}
            ]
        }
class SaudeResponse(BaseModel):
    status: str
    mensagem: str
    class Config:
        json_schema_extra = {
            "examples": [
                {"status": "OK", "mensagem": "API est√¢ÀÜ≈°√Ç¬∞ saud√¢ÀÜ≈°√Ç¬∞vel e SEGURA"}
            ]
        }
class TokenResponse(BaseModel):
    access_token: str
    token_type: str
    nivel_acesso: str
    class Config:
        json_schema_extra = {
            "examples": [
                {"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "token_type": "bearer", "nivel_acesso": "admin"}
            ]
        }
class ErrorResponse(BaseModel):
    erro: str
    detalhes: Any
    class Config:
        json_schema_extra = {
            "examples": [
                {"erro": "Erro de valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o nos dados de entrada", "detalhes": "A lista de n√¢ÀÜ≈°√¢ÀÜ¬´meros n√¢ÀÜ≈°√Ç¬£o pode estar vazia."}
            ]
        }
def gerar_token_jwt(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
        to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
def verificar_token_jwt(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
async def obter_usuario_atual_jwt(token: str = Depends(oauth2_scheme)):
    logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬≠ Validando Token JWT (ADMIN): {token[:10]}...", extra={'log_record_json': {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Token JWT inv√¢ÀÜ≈°√Ç¬∞lido ou expirado (ADMIN). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_admin"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv√¢ÀÜ≈°√Ç¬∞lidas. Token JWT ausente, inv√¢ÀÜ≈°√Ç¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload
async def obter_usuario_tester_jwt(token: str = Depends(oauth2_scheme_tester)):
    logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬≠ Validando Token JWT (TESTER): {token[:10]}...", extra={'log_record_json':  {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Token JWT inv√¢ÀÜ≈°√Ç¬∞lido ou expirado (TESTER). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_tester"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv√¢ÀÜ≈°√Ç¬∞lidas. Token JWT de tester ausente, inv√¢ÀÜ≈°√Ç¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload
@app.post("/token_admin", tags=["autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o_segura"], response_model=TokenResponse, summary="Gera token JWT seguro (credenciais 'admin/admin')")
async def gerar_token_admin_seguro(token_request: TokenRequest):
    logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o para gerar token JWT (ADMIN) recebida para usu√¢ÀÜ≈°√Ç¬∞rio: '{token_request.username}'", extra={'log_record_json': {"username": token_request.username}})
    CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    try:
        with open(ADMIN_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_admin = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Arquivo de credenciais admin n√¢ÀÜ≈°√Ç¬£o encontrado: '{ADMIN_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": ADMIN_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais n√¢ÀÜ≈°√Ç¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro ao decodificar JSON do arquivo de credenciais: '{ADMIN_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": ADMIN_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais.")
    if token_request.username == usuario_admin["username"] and token_request.password == usuario_admin["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": token_request.username, "nivel_acesso": "admin"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Token JWT (ADMIN) gerado com sucesso para usu√¢ÀÜ≈°√Ç¬∞rio 'admin'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "admin", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "admin"}
    else:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Falha na autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o (ADMIN) para usu√¢ÀÜ≈°√Ç¬∞rio '{token_request.username}'. Credenciais inv√¢ÀÜ≈°√Ç¬∞lidas.", extra={'log_record_json': {"username": token_request.username}})
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais de administrador incorretas.")
@app.post("/token_tester", tags=["autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o_segura_tester"], response_model=TokenResponse, summary="Gera token JWT seguro para TESTER (credenciais 'tester/tester')")
async def gerar_token_seguro_tester(form_data: OAuth2PasswordRequestForm = Depends()):
    logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o para gerar token JWT (TESTER) recebida para usu√¢ÀÜ≈°√Ç¬∞rio: '{form_data.username}'", extra={'log_record_json': {"username": form_data.username}})
    CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")
    try:
        with open(TESTER_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_tester = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Arquivo de credenciais tester n√¢ÀÜ≈°√Ç¬£o encontrado: '{TESTER_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": TESTER_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais de tester n√¢ÀÜ≈°√Ç¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro ao decodificar JSON do arquivo de credenciais tester: '{TESTER_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": TESTER_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais de tester.")
    if form_data.username == usuario_tester["username"] and form_data.password == usuario_tester["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": form_data.username, "nivel_acesso": "tester"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Token JWT (TESTER) gerado com sucesso para usu√¢ÀÜ≈°√Ç¬∞rio 'tester'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "tester", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "tester"}
    else:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o para /token_tester com credenciais de tester inv√¢ÀÜ≈°√Ç¬∞lidas (IGNORADO para testes API).", extra={'log_record_json': {"username": form_data.username}})
        return {"access_token": "TOKEN_INVALIDO_PARA_TESTE", "token_type": "bearer", "nivel_acesso": "tester"}
@app.post("/somar", tags=["matem√¢ÀÜ≈°√Ç¬∞tica_segura"], summary="Soma um vetor de n√¢ÀÜ≈°√¢ÀÜ¬´meros inteiros (PROTEGIDO)", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=SomaResponse, response_class=JSONResponse)
async def somar_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)):
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu√¢ÀÜ≈°√Ç¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N√¢ÀÜ≈°√¢‚Ä∞¬†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"√¢‚Ç¨≈°√É¬ª√Ç¬∞√É‚Äù√¢ÀÜ√É¬®  Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o POST em '/somar' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬¨√Ç¬∂ Corpo da requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_soma = instancia_numeros.sum_numbers(lista_numeros)
        conteudo_resposta = {"resultado": resultado_soma, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de soma bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"√¢‚Ç¨≈°√É¬ª√É¬Ø Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de soma bem-sucedida. Resultado: {resultado_soma} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_soma": resultado_soma, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o nos dados de entrada para '/somar': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Erro de tipo de dados na biblioteca calc_numbers para '/somar': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Exce√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de Valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro Cr√¢ÀÜ≈°√¢‚Ä∞¬†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})
@app.post("/calcular_media", tags=["matem√¢ÀÜ≈°√Ç¬∞tica_segura"], summary="Calcula a m√¢ÀÜ≈°√Ç¬©dia de um vetor de n√¢ÀÜ≈°√¢ÀÜ¬´meros inteiros (PROTEGIDO)", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=MediaResponse, response_class=JSONResponse)
async def calcular_media_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)):
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu√¢ÀÜ≈°√Ç¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N√¢ÀÜ≈°√¢‚Ä∞¬†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"√¢‚Ç¨≈°√É¬ª√Ç¬∞√É‚Äù√¢ÀÜ√É¬®  Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o POST em '/calcular_media' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬¨√Ç¬∂ Corpo da requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_media = instancia_numeros.calculate_average(lista_numeros)
        if resultado_media is None:
            return {"media": None, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida para lista vazia", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        conteudo_resposta = {"media": resultado_media, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"√¢‚Ç¨≈°√É¬ª√É¬≥ Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida. M√¢ÀÜ≈°√Ç¬©dia: {resultado_media} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_media": resultado_media, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o nos dados de entrada para '/calcular_media': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Erro de tipo de dados na biblioteca calc_numbers para '/calcular_media': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Exce√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de Valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro Cr√¢ÀÜ≈°√¢‚Ä∞¬†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})
@app.get("/saude", tags=["sistema_seguro"], summary="Endpoint para verificar a sa√¢ÀÜ≈°√¢ÀÜ¬´de da API (P√¢ÀÜ≈°√É¬∂BLICO)", response_class=JSONResponse, response_model=SaudeResponse)
async def verificar_saude_segura():
    timestamp = datetime.now().isoformat()
    saude_template = {
        "status": "OK",
        "version": "0.9.3",
        "ambiente": os.environ.get("API_ENVIRONMENT", "Desenvolvimento"),
        "timestamp": timestamp,
        "mensagem": "API Matem√¢ÀÜ≈°√Ç¬∞tica Segura est√¢ÀÜ≈°√Ç¬∞ operacional e respondendo.",
        "detalhes": {
            "servidor": "FastAPI",
            "seguranca": "JWT, HTTPS, Rate Limiting",
            "logs": "Detalhado em JSON"
        },
        "status_code": 200,
        "emoji_status": "√Ø¬£¬ø√É¬º√É¬∂√É‚Äû",
        "indicador_saude": "√Ø¬£¬ø√É¬º√É¬≠√É¬∂ √¢ÀÜ≈°√É¬¨timo"
    }
    return saude_template
if __name__ == "__main__":
    import uvicorn
    CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
    os.makedirs(CREDENTIALS_DIR, exist_ok=True)
    CERT_FILE = os.path.join(CREDENTIALS_DIR, "certificado.pem")
    KEY_FILE = os.path.join(CREDENTIALS_DIR, "chave.pem")
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")
    if not os.path.exists(CERT_FILE) or not os.path.exists(KEY_FILE):
        logger_app.info("√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Gerando certificados autoassinados para HTTPS...", extra={'log_record_json': {"acao": "geracao_certificados_https"}})
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())
        subject = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, "localhost")])
        builder = x509.CertificateBuilder().subject_name(subject).issuer_name(subject).public_key(private_key.public_key()).serial_number(x509.random_serial_number()).not_valid_before(datetime.utcnow()).not_valid_after(datetime.utcnow() + timedelta(days=365)).add_extension(x509.SubjectAlternativeName([x509.DNSName("localhost")]), critical=False)
        certificate = builder.sign(private_key, hashes.SHA256(), default_backend())
        with open(KEY_FILE, "wb") as key_f:
            key_f.write(private_key.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption()))
        with open(CERT_FILE, "wb") as cert_f:
            cert_f.write(certificate.public_bytes(serialization.Encoding.PEM))
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Certificados autoassinados gerados e salvos em: '{CREDENTIALS_DIR}/'", extra={'log_record_json': {"acao": "certificados_salvos", "diretorio": CREDENTIALS_DIR}})
    else:
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Certificados HTTPS autoassinados j√¢ÀÜ≈°√Ç¬∞ existentes em: '{CREDENTIALS_DIR}/'. Usando existentes.", extra={'log_record_json': {"acao": "certificados_existentes", "diretorio": CREDENTIALS_DIR}})
    if not os.path.exists(ADMIN_CREDENTIALS_FILE):
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Criando arquivo de credenciais admin padr√¢ÀÜ≈°√Ç¬£o: '{ADMIN_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_admin", "arquivo": ADMIN_CREDENTIALS_FILE}})
        admin_creds = {"username": "admin", "password": "admin"}
        with open(ADMIN_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(admin_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais admin padr√¢ÀÜ≈°√Ç¬£o criado.", extra={'log_record_json': {"acao": "creds_admin_criadas_sucesso", "arquivo": ADMIN_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais admin j√¢ÀÜ≈°√Ç¬∞ existente: '{ADMIN_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_admin_existentes", "arquivo": ADMIN_CREDENTIALS_FILE}})
    if not os.path.exists(TESTER_CREDENTIALS_FILE):
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Criando arquivo de credenciais tester padr√¢ÀÜ≈°√Ç¬£o: '{TESTER_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_tester", "arquivo": TESTER_CREDENTIALS_FILE}})
        tester_creds = {"username": "tester", "password": "tester"}
        with open(TESTER_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(tester_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais tester padr√¢ÀÜ≈°√Ç¬£o criado.", extra={'log_record_json': {"acao": "creds_tester_criadas_sucesso", "arquivo": TESTER_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais tester j√¢ÀÜ≈°√Ç¬∞ existente: '{TESTER_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_tester_existentes", "arquivo": TESTER_CREDENTIALS_FILE}})
    uvicorn.run(app, host="0.0.0.0", port=8882, ssl_certfile=CERT_FILE, ssl_keyfile=KEY_FILE)
ƒü≈∏‚Äú‚Äû Arquivo: .\app\API-main-server-prod.py
  Tamanho: 0.03 MB (27.37 KB, 28030 bytes)
  N√É¬∫mero de Linhas: 383

  C√É¬≥digo Fonte:
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import logging
import json
from datetime import datetime, timedelta
from typing import List, Optional, Any
from fastapi import FastAPI, Request, HTTPException, Depends, status
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, ValidationError
from jose import JWTError, jwt
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from bibliotecas.calc_numbers import Numbers

# √¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬® Configura√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬µes da API (vari√¢ÀÜ≈°√Ç¬∞veis de ambiente ou valores padr√¢ÀÜ≈°√Ç¬£o)
SECRET_KEY = os.environ.get("API_SECRET_KEY", "Jump@d2025!!(SegredoSuperSeguroParaTesteAPI)")
ALGORITHM = os.environ.get("API_JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.environ.get("API_TOKEN_EXPIRY_MINUTES", "30"))
RATE_LIMIT_REQUESTS_PER_MINUTE = int(os.environ.get("API_RATE_LIMIT", "200"))
DIRETORIO_LOGS = os.environ.get("API_LOG_DIR", "logs")
CREDENTIALS_DIR = os.environ.get("API_CREDENTIALS_DIR", "credentials")
origins_permitidas = os.environ.get("API_CORS_ORIGINS", "http://localhost").split(",")

# √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Esquemas de seguran√¢ÀÜ≈°√É≈∏a OAuth2 para tokens JWT
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token_admin") # √Ø¬£¬ø√É¬º√É¬µ√Ç¬∞√É‚Äù√¢ÀÜ√É¬® Define esquema de seguran√¢ÀÜ≈°√É≈∏a para token de admin
oauth2_scheme_tester = OAuth2PasswordBearer(tokenUrl="token_tester") # √Ø¬£¬ø√É¬º√É¬µ√Ç¬∞√É‚Äù√¢ÀÜ√É¬® Define esquema de seguran√¢ÀÜ≈°√É≈∏a para token de tester

# √Ø¬£¬ø√É¬º√¢‚Äû¬¢√Ç¬µ Configura√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de Logging (logs coloridos no console e logs JSON em arquivos)
if not os.path.exists(DIRETORIO_LOGS):
    os.makedirs(DIRETORIO_LOGS)
ARQUIVO_LOG_API = os.path.join(DIRETORIO_LOGS, "api-logs.json")
ARQUIVO_LOG_DETALHADO_API = os.path.join(DIRETORIO_LOGS, "api-detailed-logs.json")

class FormatterColoridoSeguro(logging.Formatter): # √¢‚Ç¨≈°√É¬∫√Ç¬Æ Formatter para logs coloridos no console
    CORES = {
        'DEBUG': '\033[94m',    'INFO': '\033[92m',     'WARNING': '\033[93m',
        'ERROR': '\033[91m',    'CRITICAL': '\033[97;41m', 'RESET': '\033[0m'
    }
    EMOJIS = {
        'DEBUG': '√Ø¬£¬ø√É¬º√É¬™√É¬µ', 'INFO': '√¢‚Ç¨≈°√É¬∫√É‚Äì', 'WARNING': '√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬®', 'ERROR': '√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢', 'CRITICAL': '√Ø¬£¬ø√É¬º√É¬∂√Ç¬Æ'
    }
    def format(self, record):
        cor_log = self.CORES.get(record.levelname, self.CORES['INFO'])
        reset_cor = self.CORES['RESET']
        emoji = self.EMOJIS.get(record.levelname, '')
        nivel_log = f"{cor_log}{record.levelname}{reset_cor}"
        mensagem = f"{cor_log}{record.getMessage()}{reset_cor}"
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"{timestamp} - {emoji} {nivel_log} - {record.name}:{record.lineno} - {mensagem}"

console_handler = logging.StreamHandler() # √¢‚Ç¨≈°√É¬∫√É¬ß√É‚Äù√¢ÀÜ√É¬® Handler para logs no console
console_handler.setFormatter(FormatterColoridoSeguro())
api_log_handler = logging.FileHandler(ARQUIVO_LOG_API, encoding='utf-8') # √¢‚Ç¨≈°√É¬∫√É¬ß√É‚Äù√¢ÀÜ√É¬® Handler para logs JSON resumidos
api_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s", "detalhes": %(log_record_json)s}')
api_log_handler.setFormatter(api_log_formatter)
api_detailed_log_handler = logging.FileHandler(ARQUIVO_LOG_DETALHADO_API, encoding='utf-8') # √¢‚Ç¨≈°√É¬∫√É¬ß√É‚Äù√¢ÀÜ√É¬® Handler para logs JSON detalhados
api_detailed_log_formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "name": "%(name)s", "line": "%(lineno)d", "message": "%(message)s", "record": %(log_record_json)s}')
api_detailed_log_handler.setFormatter(api_detailed_log_formatter)

logger_app = logging.getLogger("api_server") # √Ø¬£¬ø√É¬º√¢‚Äû¬¢√Ç¬µ Logger principal da aplica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o
logger_app.setLevel(logging.DEBUG)
logger_app.addHandler(console_handler)
logger_app.addHandler(api_log_handler)
logger_app.addHandler(api_detailed_log_handler)

# √Ø¬£¬ø√É¬º√É¬∂√É‚Äû Inicializa√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o da Aplica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o FastAPI
app = FastAPI(
    title="API Matem√¢ÀÜ≈°√Ç¬∞tica Segura",
    description="API RESTful para opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬µes de soma e m√¢ÀÜ≈°√Ç¬©dia - SEGURA (N√¢ÀÜ≈°√¢‚Ä∞¬†vel M√¢ÀÜ≈°√Ç¬∞ximo) com autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o JWT e HTTPS.",
    version="0.9.3"
)

# √¢‚Ç¨≈°√É≈ì√É¬Æ√É‚Äù√¢ÀÜ√É¬® Configura√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de CORS (Cross-Origin Resource Sharing) - Ajuste 'origins_permitidas' conforme necess√¢ÀÜ≈°√Ç¬∞rio
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins_permitidas,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# √Ø¬£¬ø√É¬º√É¬µ√Ç¬∞√É‚Äù√¢ÀÜ√É¬® Modelos de Dados (Pydantic) para Valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o e Documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o Autom√¢ÀÜ≈°√Ç¬∞tica

class NumerosEntrada(BaseModel): # Modelo para lista de n√¢ÀÜ≈°√¢ÀÜ¬´meros na requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o
    numeros: List[int]
    model_config = {
        "json_schema_extra": {
            "examples": [
                {"numeros": [1, 2, 3, 4]} # Exemplo para documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o Swagger/ReDoc
            ]
        }
    }

class TokenRequest(BaseModel): # Modelo para requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de token
    username: str
    password: str

class TokenResponse(BaseModel): # Modelo para resposta de token JWT
    access_token: str
    token_type: str
    nivel_acesso: str
    model_config = {
        "json_schema_extra": {
            "examples": [
                {"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "token_type": "bearer", "nivel_acesso": "admin"} # Exemplo token
            ]
        }
    }

class SomaResponse(BaseModel): # Modelo para resposta da rota /somar
    resultado: int
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"resultado": 10, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de soma bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"} # Exemplo soma
            ]
        }

class MediaResponse(BaseModel): # Modelo para resposta da rota /calcular_media
    media: Optional[float] = None
    mensagem: str
    numeros_entrada: List[int]
    usuario: Optional[str] = None
    nivel_acesso: Optional[str] = None
    class Config:
        json_schema_extra = {
            "examples": [
                {"media": 2.5, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida", "numeros_entrada": [1, 2, 3, 4], "usuario": "admin", "nivel_acesso": "admin"} # Exemplo m√¢ÀÜ≈°√Ç¬©dia
            ]
        }

class SaudeResponse(BaseModel): # Modelo para resposta da rota /saude
    status: str
    mensagem: str
    class Config:
        json_schema_extra = {
            "examples": [
                {"status": "OK", "mensagem": "API est√¢ÀÜ≈°√Ç¬∞ saud√¢ÀÜ≈°√Ç¬∞vel e SEGURA"} # Exemplo sa√¢ÀÜ≈°√¢ÀÜ¬´de
            ]
        }

class ErrorResponse(BaseModel): # Modelo para respostas de erro
    erro: str
    detalhes: Any
    class Config:
        json_schema_extra = {
            "examples": [
                {"erro": "Erro de valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o nos dados de entrada", "detalhes": "A lista de n√¢ÀÜ≈°√¢ÀÜ¬´meros n√¢ÀÜ≈°√Ç¬£o pode estar vazia."} # Exemplo erro
            ]
        }

# √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Fun√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬µes de Seguran√¢ÀÜ≈°√É≈∏a (JWT - JSON Web Tokens)

def gerar_token_jwt(data: dict, expires_delta: Optional[timedelta] = None) -> str: # √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Gera token JWT
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
        to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verificar_token_jwt(token: str) -> Optional[dict]: # √¢‚Ç¨≈°√É¬∫√É‚Äì Verifica e decodifica token JWT
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None

async def obter_usuario_atual_jwt(token: str = Depends(oauth2_scheme)) -> dict: # √Ø¬£¬ø√É¬º√É¬µ√Ç¬∞√É‚Äù√¢ÀÜ√É¬® Depend√¢ÀÜ≈°√¢‚Äû¬¢ncia para obter usu√¢ÀÜ≈°√Ç¬∞rio ADMIN atual via JWT
    logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬≠ Validando Token JWT (ADMIN): {token[:10]}...", extra={'log_record_json': {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Token JWT inv√¢ÀÜ≈°√Ç¬∞lido ou expirado (ADMIN). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_admin"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv√¢ÀÜ≈°√Ç¬∞lidas. Token JWT ausente, inv√¢ÀÜ≈°√Ç¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload

async def obter_usuario_tester_jwt(token: str = Depends(oauth2_scheme_tester)) -> dict: # √Ø¬£¬ø√É¬º√É¬µ√Ç¬∞√É‚Äù√¢ÀÜ√É¬® Depend√¢ÀÜ≈°√¢‚Äû¬¢ncia para obter usu√¢ÀÜ≈°√Ç¬∞rio TESTER atual via JWT
    logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬≠ Validando Token JWT (TESTER): {token[:10]}...", extra={'log_record_json':  {"token_prefix": token[:10]}})
    payload = verificar_token_jwt(token)
    if payload is None:
        logger_app.warning("√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Token JWT inv√¢ÀÜ≈°√Ç¬∞lido ou expirado (TESTER). Acesso negado.", extra={'log_record_json': {"status_auth": "falha_token_invalido_tester"}})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inv√¢ÀÜ≈°√Ç¬∞lidas. Token JWT de tester ausente, inv√¢ÀÜ≈°√Ç¬∞lido ou expirado.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return payload

# √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Endpoints de Autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o Segura (JWT)

@app.post("/token_admin", tags=["autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o_segura"], response_model=TokenResponse, summary="Gera token JWT seguro para Administradores", description="Endpoint para gerar um token JWT de acesso com n√¢ÀÜ≈°√¢‚Ä∞¬†vel 'admin'. Requer credenciais de administrador.")
async def gerar_token_admin_seguro(token_request: TokenRequest): # √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Rota para gerar token JWT de ADMIN
    logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o para gerar token JWT (ADMIN) recebida para usu√¢ÀÜ≈°√Ç¬∞rio: '{token_request.username}'", extra={'log_record_json': {"username": token_request.username}})
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    try:
        with open(ADMIN_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_admin = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Arquivo de credenciais admin n√¢ÀÜ≈°√Ç¬£o encontrado: '{ADMIN_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": ADMIN_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais n√¢ÀÜ≈°√Ç¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro ao decodificar JSON do arquivo de credenciais: '{ADMIN_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": ADMIN_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais.")
    if token_request.username == usuario_admin["username"] and token_request.password == usuario_admin["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": token_request.username, "nivel_acesso": "admin"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Token JWT (ADMIN) gerado com sucesso para usu√¢ÀÜ≈°√Ç¬∞rio 'admin'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "admin", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "admin"}
    else:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Falha na autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o (ADMIN) para usu√¢ÀÜ≈°√Ç¬∞rio '{token_request.username}'. Credenciais inv√¢ÀÜ≈°√Ç¬∞lidas.", extra={'log_record_json': {"username": token_request.username}})
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais de administrador incorretas.")

@app.post("/token_tester", tags=["autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o_segura_tester"], response_model=TokenResponse, summary="Gera token JWT seguro para Testers", description="Endpoint para gerar um token JWT de acesso com n√¢ÀÜ≈°√¢‚Ä∞¬†vel 'tester'. Requer credenciais de tester.")
async def gerar_token_seguro_tester(form_data: OAuth2PasswordRequestForm = Depends()): # √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Rota para gerar token JWT de TESTER
    logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o para gerar token JWT (TESTER) recebida para usu√¢ÀÜ≈°√Ç¬∞rio: '{form_data.username}'", extra={'log_record_json': {"username": form_data.username}})
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")
    try:
        with open(TESTER_CREDENTIALS_FILE, "r", encoding='utf-8') as f:
            usuario_tester = json.load(f)
    except FileNotFoundError:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Arquivo de credenciais tester n√¢ÀÜ≈°√Ç¬£o encontrado: '{TESTER_CREDENTIALS_FILE}'.", extra={'log_record_json': {"erro": "FileNotFoundError", "arquivo": TESTER_CREDENTIALS_FILE}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Arquivo de credenciais de tester n√¢ÀÜ≈°√Ç¬£o encontrado.")
    except json.JSONDecodeError as e:
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro ao decodificar JSON do arquivo de credenciais tester: '{TESTER_CREDENTIALS_FILE}'. Detalhes: {e}", extra={'log_record_json': {"erro": "JSONDecodeError", "arquivo": TESTER_CREDENTIALS_FILE, "detalhe_erro": str(e)}})
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Erro interno: Falha ao ler arquivo de credenciais de tester.")
    if form_data.username == usuario_tester["username"] and form_data.password == usuario_tester["password"]:
        tempo_expiracao_token = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_jwt = gerar_token_jwt(data={"sub": form_data.username, "nivel_acesso": "tester"}, expires_delta=tempo_expiracao_token)
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Token JWT (TESTER) gerado com sucesso para usu√¢ÀÜ≈°√Ç¬∞rio 'tester'. Expira em {ACCESS_TOKEN_EXPIRE_MINUTES} minutos.", extra={'log_record_json': {"usuario": "tester", "expira_em_minutos": ACCESS_TOKEN_EXPIRE_MINUTES}})
        return {"access_token": token_jwt, "token_type": "bearer", "nivel_acesso": "tester"}
    else:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o para /token_tester com credenciais de tester inv√¢ÀÜ≈°√Ç¬∞lidas (IGNORADO para testes API).", extra={'log_record_json': {"username": form_data.username}})
        return {"access_token": "TOKEN_INVALIDO_PARA_TESTE", "token_type": "bearer", "nivel_acesso": "tester"}

# √¢‚Ç¨≈°√É¬ª√É¬Ø Endpoints de Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬µes Matem√¢ÀÜ≈°√Ç¬∞ticas (PROTEGIDOS por JWT)

@app.post("/somar", tags=["matem√¢ÀÜ≈°√Ç¬∞tica_segura"], summary="Soma um vetor de n√¢ÀÜ≈°√¢ÀÜ¬´meros inteiros", description="Endpoint PROTEGIDO que realiza a soma de uma lista de n√¢ÀÜ≈°√¢ÀÜ¬´meros inteiros fornecida no corpo da requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o. Requer token JWT de administrador v√¢ÀÜ≈°√Ç¬∞lido.", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=SomaResponse, response_class=JSONResponse)
async def somar_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)): # √¢‚Ç¨≈°√É¬ª√É¬Ø Rota para somar vetor (PROTEGIDA)
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu√¢ÀÜ≈°√Ç¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N√¢ÀÜ≈°√¢‚Ä∞¬†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"√¢‚Ç¨≈°√É¬ª√Ç¬∞√É‚Äù√¢ÀÜ√É¬®  Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o POST em '/somar' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬¨√Ç¬∂ Corpo da requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_soma = instancia_numeros.sum_numbers(lista_numeros)
        conteudo_resposta = {"resultado": resultado_soma, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de soma bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"√¢‚Ç¨≈°√É¬ª√É¬Ø Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de soma bem-sucedida. Resultado: {resultado_soma} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_soma": resultado_soma, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o nos dados de entrada para '/somar': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Erro de tipo de dados na biblioteca calc_numbers para '/somar': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Exce√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de Valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro Cr√¢ÀÜ≈°√¢‚Ä∞¬†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})

@app.post("/calcular_media", tags=["matem√¢ÀÜ≈°√Ç¬∞tica_segura"], summary="Calcula a m√¢ÀÜ≈°√Ç¬©dia de um vetor de n√¢ÀÜ≈°√¢ÀÜ¬´meros inteiros", description="Endpoint PROTEGIDO que calcula a m√¢ÀÜ≈°√Ç¬©dia de uma lista de n√¢ÀÜ≈°√¢ÀÜ¬´meros inteiros fornecida. Requer token JWT de administrador v√¢ÀÜ≈°√Ç¬∞lido.", dependencies=[Depends(obter_usuario_atual_jwt)], response_model=MediaResponse, response_class=JSONResponse)
async def calcular_media_vetor(request: Request, numeros_entrada: NumerosEntrada, usuario: dict = Depends(obter_usuario_atual_jwt)): # √¢‚Ç¨≈°√É¬ª√É¬≥ Rota para calcular m√¢ÀÜ≈°√Ç¬©dia vetor (PROTEGIDA)
    detalhes_requisicao = f"Cliente: {request.client.host if request.client else 'desconhecido'}, URL: {request.url.path}, Usu√¢ÀÜ≈°√Ç¬∞rio JWT (ADMIN): {usuario.get('sub') if usuario else 'desconhecido'}, N√¢ÀÜ≈°√¢‚Ä∞¬†vel Acesso: {usuario.get('nivel_acesso') if usuario else 'desconhecido'}, HTTPS={request.url.scheme == 'https'}, Rate Limited=SIM"
    logger_app.info(f"√¢‚Ç¨≈°√É¬ª√Ç¬∞√É‚Äù√¢ÀÜ√É¬®  Requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o POST em '/calcular_media' (PROTEGIDO) de {detalhes_requisicao}", extra={'log_record_json': {}})
    try:
        lista_numeros = numeros_entrada.numeros
        logger_app.debug(f"√Ø¬£¬ø√É¬º√É¬¨√Ç¬∂ Corpo da requisi√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o JSON recebido e VALIDADO (Pydantic): {lista_numeros}", extra={'log_record_json': {"numeros_entrada": lista_numeros}})
        instancia_numeros = Numbers()
        resultado_media = instancia_numeros.calculate_average(lista_numeros)
        if resultado_media is None:
            return {"media": None, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida para lista vazia", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        conteudo_resposta = {"media": resultado_media, "mensagem": "Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida", "numeros_entrada": lista_numeros, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}
        logger_app.info(f"√¢‚Ç¨≈°√É¬ª√É¬≥ Opera√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de m√¢ÀÜ≈°√Ç¬©dia bem-sucedida. M√¢ÀÜ≈°√Ç¬©dia: {resultado_media} - {detalhes_requisicao}", extra={'log_record_json': {"resultado_media": resultado_media, "usuario": usuario.get('sub'), "nivel_acesso": usuario.get('nivel_acesso')}})
        return conteudo_resposta
    except ValueError as e_calc_value:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o nos dados de entrada para '/calcular_media': {e_calc_value} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_value)}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e_calc_value))
    except TypeError as e_calc_type:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Erro de tipo de dados na biblioteca calc_numbers para '/calcular_media': {e_calc_type} - {detalhes_requisicao}", extra={'log_record_json': {"erro_biblioteca": str(e_calc_type)}})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e_calc_type))
    except HTTPException as exc_http:
        logger_app.error(f"√Ø¬£¬ø√É¬º√É¬Æ√¢‚Ç¨¬¢ Exce√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o HTTP: {exc_http.detail} - Status Code: {exc_http.status_code} - {detalhes_requisicao}", extra={'log_record_json': {"erro_http": exc_http.detail, "status_code": exc_http.status_code}})
        raise JSONResponse(status_code=exc_http.status_code, content={"erro": exc_http.detail})
    except ValidationError as ve:
        logger_app.warning(f"√¢‚Ç¨≈°√É¬∂√¢‚Ç¨¬†√É‚Äù√¢ÀÜ√É¬® Erro de Valida√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o de Entrada (Pydantic): {ve.errors()} - {detalhes_requisicao}", extra={'log_record_json': {"erro_validacao": ve.errors()}})
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=ve.errors())
    except Exception as e:
        msg_detalhe_erro = f"Erro inesperado no servidor: {str(e)}"
        logger_app.critical(f"√Ø¬£¬ø√É¬º√É¬≠√¢‚Ç¨¬¢ Erro Cr√¢ÀÜ≈°√¢‚Ä∞¬†tico no Servidor: {msg_detalhe_erro} - {detalhes_requisicao}", exc_info=True, extra={'log_record_json': {"erro_servidor": msg_detalhe_erro, "exception": str(e)}})
        return JSONResponse(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, content={"erro": "Erro interno do servidor", "detalhes": msg_detalhe_erro})

# √Ø¬£¬ø√É¬º√Ç¬©√¢ÀÜ¬´ Endpoint de Sa√¢ÀÜ≈°√¢ÀÜ¬´de da API (P√¢ÀÜ≈°√É¬∂BLICO - Sem Autentica√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o)

@app.get("/saude", tags=["sistema_seguro"], summary="Verifica a sa√¢ÀÜ≈°√¢ÀÜ¬´de da API", description="Endpoint P√¢ÀÜ≈°√É¬∂BLICO para verificar se a API est√¢ÀÜ≈°√Ç¬∞ online e funcionando corretamente.", response_class=JSONResponse, response_model=SaudeResponse)
async def verificar_saude_segura(): # √Ø¬£¬ø√É¬º√Ç¬©√¢ÀÜ¬´ Rota de sa√¢ÀÜ≈°√¢ÀÜ¬´de da API (P√¢ÀÜ≈°√É¬∂BLICA)
    timestamp = datetime.now().isoformat()
    saude_template = {
        "status": "OK",
        "version": "0.9.3",
        "ambiente": os.environ.get("API_ENVIRONMENT", "Desenvolvimento"),
        "timestamp": timestamp,
        "mensagem": "API Matem√¢ÀÜ≈°√Ç¬∞tica Segura est√¢ÀÜ≈°√Ç¬∞ operacional e respondendo.",
        "detalhes": {
            "servidor": "FastAPI",
            "seguranca": "JWT, HTTPS, Rate Limiting",
            "logs": "Detalhado em JSON"
        },
        "status_code": 200,
        "emoji_status": "√Ø¬£¬ø√É¬º√É¬∂√É‚Äû",
        "indicador_saude": "√Ø¬£¬ø√É¬º√É¬≠√É¬∂ √¢ÀÜ≈°√É¬¨timo"
    }
    return saude_template

# √¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬® Execu√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o do Servidor Uvicorn (HTTPS)
if __name__ == "__main__":
    import uvicorn

    # √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Cria diret√¢ÀÜ≈°√¢‚Ä∞¬•rio para credenciais e certificados se n√¢ÀÜ≈°√Ç¬£o existirem
    os.makedirs(CREDENTIALS_DIR, exist_ok=True)
    CERT_FILE = os.path.join(CREDENTIALS_DIR, "certificado.pem")
    KEY_FILE = os.path.join(CREDENTIALS_DIR, "chave.pem")
    ADMIN_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "admin_credentials.json")
    TESTER_CREDENTIALS_FILE = os.path.join(CREDENTIALS_DIR, "tester_credentials.json")

    # √Ø¬£¬ø√É¬º√É¬Æ√É¬´ Gera certificados autoassinados HTTPS se n√¢ÀÜ≈°√Ç¬£o existirem
    if not os.path.exists(CERT_FILE) or not os.path.exists(KEY_FILE):
        logger_app.info("√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Gerando certificados autoassinados para HTTPS...", extra={'log_record_json': {"acao": "geracao_certificados_https"}})
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())
        subject = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, "localhost")])
        builder = x509.CertificateBuilder().subject_name(subject).issuer_name(subject).public_key(private_key.public_key()).serial_number(x509.random_serial_number()).not_valid_before(datetime.utcnow()).not_valid_after(datetime.utcnow() + timedelta(days=365)).add_extension(x509.SubjectAlternativeName([x509.DNSName("localhost")]), critical=False)
        certificate = builder.sign(private_key, hashes.SHA256(), default_backend())
        with open(KEY_FILE, "wb") as key_f:
            key_f.write(private_key.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption()))
        with open(CERT_FILE, "wb") as cert_f:
            cert_f.write(certificate.public_bytes(serialization.Encoding.PEM))
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Certificados autoassinados gerados e salvos em: '{CREDENTIALS_DIR}/'", extra={'log_record_json': {"acao": "certificados_salvos", "diretorio": CREDENTIALS_DIR}})
    else:
        logger_app.info(f"√Ø¬£¬ø√É¬º√É¬Æ√É¬´ Certificados HTTPS autoassinados j√¢ÀÜ≈°√Ç¬∞ existentes em: '{CREDENTIALS_DIR}/'. Usando existentes.", extra={'log_record_json': {"acao": "certificados_existentes", "diretorio": CREDENTIALS_DIR}})

    # √¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬® Cria arquivos de credenciais padr√¢ÀÜ≈°√Ç¬£o (admin/admin, tester/tester) se n√¢ÀÜ≈°√Ç¬£o existirem
    if not os.path.exists(ADMIN_CREDENTIALS_FILE):
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Criando arquivo de credenciais admin padr√¢ÀÜ≈°√Ç¬£o: '{ADMIN_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_admin", "arquivo": ADMIN_CREDENTIALS_FILE}})
        admin_creds = {"username": "admin", "password": "admin"}
        with open(ADMIN_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(admin_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais admin padr√¢ÀÜ≈°√Ç¬£o criado.", extra={'log_record_json': {"acao": "creds_admin_criadas_sucesso", "arquivo": ADMIN_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais admin j√¢ÀÜ≈°√Ç¬∞ existente: '{ADMIN_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_admin_existentes", "arquivo": ADMIN_CREDENTIALS_FILE}})

    if not os.path.exists(TESTER_CREDENTIALS_FILE):
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Criando arquivo de credenciais tester padr√¢ÀÜ≈°√Ç¬£o: '{TESTER_CREDENTIALS_FILE}'...", extra={'log_record_json': {"acao": "criacao_creds_tester", "arquivo": TESTER_CREDENTIALS_FILE}})
        tester_creds = {"username": "tester", "password": "tester"}
        with open(TESTER_CREDENTIALS_FILE, "w", encoding='utf-8') as f:
            json.dump(tester_creds, f, indent=4, ensure_ascii=False)
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais tester padr√¢ÀÜ≈°√Ç¬£o criado.", extra={'log_record_json': {"acao": "creds_tester_criadas_sucesso", "arquivo": TESTER_CREDENTIALS_FILE}})
    else:
        logger_app.info(f"√¢‚Ç¨≈°√É¬∂√É¬¥√É‚Äù√¢ÀÜ√É¬®  Arquivo de credenciais tester j√¢ÀÜ≈°√Ç¬∞ existente: '{TESTER_CREDENTIALS_FILE}'. Usando existente.", extra={'log_record_json': {"acao": "creds_tester_existentes", "arquivo": TESTER_CREDENTIALS_FILE}})

    # √Ø¬£¬ø√É¬º√É¬∂√É‚Äû Inicia o servidor Uvicorn com HTTPS e documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o Swagger/ReDoc AUTOM√¢ÀÜ≈°√É‚Ä¶TICA no /docs e /redoc
    print("√¢‚Ç¨≈°√É¬∫√É‚Äì Servidor FastAPI inicializado. ")
    print("√¢‚Ç¨≈°√É¬ª√Ç¬∞√É‚Äù√¢ÀÜ√É¬®  Acesse a documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o interativa Swagger UI em: http://localhost:8882/docs") # √Ø¬£¬ø√É¬º√É¬¨√É¬± Instru√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬µes Swagger UI
    print("√¢‚Ç¨≈°√É¬ª√Ç¬∞√É‚Äù√¢ÀÜ√É¬®  Acesse a documenta√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬£o alternativa ReDoc em: http://localhost:8882/redoc") # √Ø¬£¬ø√É¬º√É¬¨√É¬∂ Instru√¢ÀÜ≈°√É≈∏√¢ÀÜ≈°√Ç¬µes ReDoc
    uvicorn.run(app, host="0.0.0.0", port=8882, ssl_certfile=CERT_FILE, ssl_keyfile=KEY_FILE)
üìÑ Arquivo: .\docs\project_structure.txt
  Tamanho: 0.00 MB (1.21 KB, 1238 bytes)
  N√∫mero de Linhas: 48

  C√≥digo Fonte:
DOCUMENTA√á√ÉO AUTOM√ÅTICA DA ESTRUTURA DO PROJETO
---------------------------------------------------
Gerado por: doc_gen.py
Data de Gera√ß√£o: 10/03/2025 00:32:43
Codifica√ß√£o do Arquivo: UTF-8

Estrutura de diret√≥rios e arquivos a partir da raiz do projeto:

./
  .gitignore
  CHANGELOG.md
  Dockerfile
  doc_gen_full.py
  README.md
  requirements.txt
  app/
    API-main-server-mvp.py
    API-main-server-prod.py
  bibliotecas/
    calc_numbers.py
    __pycache__/
      calc_numbers.cpython-310.pyc
  config/
  credentials/
    admin_credentials.json
    certificado.pem
    chave.pem
    tester_credentials.json
  docs/
    project_structure.txt
  exceptions/
  logs/
    api-detailed-logs.json
    api-logs.json
  schemas/
  tests/
    api_main_tester_v1.py
    api_main_tester_v2.py.py
    test_lib_calc_numbers.py
  test_logs/
    log_teste_1.json

---------------------------------------------------
Fim da Documenta√ß√£o da Estrutura do Projeto.

Este arquivo foi gerado automaticamente. Para atualizar a documenta√ß√£o,
execute o script novamente: 'python doc_gen.py'
Certifique-se de que seu editor de texto/visualizador utilize UTF-8 para exibir corretamente os caracteres.

üìÑ Arquivo: .\logs\api-detailed-logs.json
  Tamanho: 0.06 MB (58.24 KB, 59635 bytes)
  N√∫mero de Linhas: 228
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\logs\api-logs.json
  Tamanho: 0.05 MB (50.44 KB, 51655 bytes)
  N√∫mero de Linhas: 228
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.

üìÑ Arquivo: .\tests\api_main_tester_v1.py
  Tamanho: 0.01 MB (12.89 KB, 13204 bytes)
  N√∫mero de Linhas: 254

  C√≥digo Fonte:
import requests
import json
import os
import unittest
import time
from datetime import datetime
import colorama
from colorama import Fore, Back, Style

colorama.init(autoreset=True)

API_BASE_URL = os.environ.get("API_TEST_URL", "https://localhost:8882")
VERIFY_SSL_CERT = os.environ.get("API_VERIFY_SSL", False) == 'True'
LOG_DIR = "test_logs"
LOG_FILE = os.path.join(LOG_DIR, "api-test-log.json")

ADMIN_TOKEN = None

def obter_token_admin():
    global ADMIN_TOKEN
    token_url = f"{API_BASE_URL}/token_admin"
    credenciais = {"username": "admin", "password": "admin"}
    try:
        resposta = requests.post(token_url, json=credenciais, verify=VERIFY_SSL_CERT)
        resposta.raise_for_status()
        ADMIN_TOKEN = resposta.json().get("access_token")
        return ADMIN_TOKEN
    except requests.exceptions.RequestException as e:
        print(Fore.RED + Style.BRIGHT + f"Ô£ø√º√Æ‚Ä¢ Erro ao obter token ADMIN: {e}" + Style.RESET_ALL)
        return None

def colored_print_success(msg):
    print(Fore.GREEN + Style.BRIGHT + "‚Äö√∫√ñ " + msg + Style.RESET_ALL)

def colored_print_failure(msg):
    print(Fore.RED + Style.BRIGHT + "‚Äö√π√• " + msg + Style.RESET_ALL)

def colored_print_info(msg):
    print(Fore.CYAN + Style.BRIGHT + "‚Äö√ëœÄ√î‚àè√®  " + msg + Style.RESET_ALL)

def colored_print_warning(msg):
    print(Fore.YELLOW + Style.BRIGHT + "‚Äö√∂‚Ä†√î‚àè√®  " + msg + Style.RESET_ALL)

def colored_print_header(msg):
    print(Back.BLUE + Fore.WHITE + Style.BRIGHT + " " + msg + " " + Style.RESET_ALL)

class ApiTests(unittest.TestCase):

    def setUp(self):
        global ADMIN_TOKEN
        if not ADMIN_TOKEN:
            ADMIN_TOKEN = obter_token_admin()
            if not ADMIN_TOKEN:
                self.skipTest("Token ADMIN n‚àö¬£o obtido, pulando testes protegidos.")
        self.admin_token = ADMIN_TOKEN
        self.headers_admin = {"Authorization": f"Bearer {self.admin_token}"}
        self.log_entries = []

    def tearDown(self):
        end_time = time.time()
        test_duration = end_time - self.start_test_time
        status = "PASSOU" if not self._outcome.errors and not self._outcome.failures else "FALHOU"

        log_entry = {
            "test_name": self._testMethodName,
            "status": status,
            "duration_seconds": f"{test_duration:.4f}",
            "timestamp": datetime.now().isoformat(),
            "details": self.current_test_log
        }
        self.log_entries.append(log_entry)
        self._save_log_to_file()


    def _start_test_logging(self, test_name):
        self.current_test_log = []
        self.start_test_time = time.time()

    def _log_request_response(self, method, url, headers, data, response):
        log_data = {
            "request": {
                "method": method,
                "url": url,
                "headers": headers,
                "data": data if method == 'POST' else None,
                "json": data if method == 'POST' else None
            },
            "response": {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "body": response.text
            }
        }
        self.current_test_log.append(log_data)

    def _save_log_to_file(self):
        if not os.path.exists(LOG_DIR):
            os.makedirs(LOG_DIR)
        log_header = {"test_run_timestamp": datetime.now().isoformat(), "test_suite": "ApiTests"}

        try:
            file_exists = os.path.exists(LOG_FILE)
            with open(LOG_FILE, 'a') as f:
                if not file_exists:
                    f.write('{"test_runs": [\n')
                else:
                    f.write(',\n')

                json.dump(log_header, f, indent=4, ensure_ascii=False)
                f.write(',\n"tests": [\n')

                for i, entry in enumerate(self.log_entries):
                    json.dump(entry, f, indent=4, ensure_ascii=False)
                    if i < len(self.log_entries) - 1:
                        f.write(',')
                    f.write('\n')

                f.write(']\n}')
                self.log_entries = []

        except Exception as e:
            colored_print_failure(f"‚Äö√π√• Erro ao salvar log em '{LOG_FILE}': {e}")


    def _testar_rota_post(self, url_path, token_headers, data, expected_status=200, expected_result_key=None, expected_result_value=None, test_name="Rota POST"):
        url = f"{API_BASE_URL}{url_path}"
        self._start_test_logging(test_name)

        resposta = requests.post(url, headers=token_headers, json=data, verify=VERIFY_SSL_CERT)
        self._log_request_response('POST', url, token_headers, data, resposta)

        if resposta.status_code != expected_status:
            colored_print_failure(f"‚Äö√π√• {test_name} FALHOU: Status code incorreto. Esperado: {expected_status}, Obtido: {resposta.status_code}. Response Body: {resposta.text}")
            self.assertEqual(resposta.status_code, expected_status)
            return

        if expected_status < 400 and expected_result_key:
            try:
                response_json = resposta.json()
                actual_value = response_json.get(expected_result_key)
                if expected_result_value is not None:
                    if actual_value == expected_result_value:
                        colored_print_success(f"‚Äö√∫√ñ {test_name} OK: Valor de '{expected_result_key}' validado. ({expected_result_value})")
                    else:
                        colored_print_failure(f"‚Äö√π√• {test_name} FALHOU: Valor incorreto para chave '{expected_result_key}'. Esperado: {expected_result_value}, Obtido: {actual_value}. Response: {response_json}")
                        self.fail(f"Valor incorreto para chave '{expected_result_key}'. Esperado: {expected_result_value}, Obtido: {actual_value}")
                else:
                    if expected_result_key in response_json:
                        colored_print_success(f"‚Äö√∫√ñ {test_name} OK: Chave '{expected_result_key}' presente na resposta.")
                    else:
                        colored_print_failure(f"‚Äö√π√• {test_name} FALHOU: Chave '{expected_result_key}' ausente na resposta JSON. Response: {response_json}")
                        self.fail(f"Chave '{expected_result_key}' ausente na resposta JSON.")
            except json.JSONDecodeError:
                self.fail(f"‚Äö√π√• {test_name} FALHOU: Erro ao decodificar JSON. Response text: {resposta.text}")
        return resposta


    def test_rota_saude(self):
        resposta = requests.get(f"{API_BASE_URL}/saude", verify=VERIFY_SSL_CERT)
        self.assertEqual(resposta.status_code, 200, colored_print_failure(f"Rota /saude falhou, status code: {resposta.status_code}"))
        if resposta.status_code == 200:
            try:
                response_json = resposta.json()
                if response_json.get("status") == "OK":
                    colored_print_success(f"‚Äö√∫√ñ Teste /saude OK: Status 'OK' encontrado na resposta JSON.")
                else:
                    colored_print_failure(f"‚Äö√π√• /saude - status incorreto na resposta JSON. Esperado 'OK', obtido: '{response_json.get('status')}'")
                    self.assertEqual(response_json.get("status"), "OK")

                if "mensagem" in response_json:
                    colored_print_success(f"‚Äö√∫√ñ Teste /saude OK: Chave 'mensagem' encontrada na resposta JSON.")
                else:
                    colored_print_failure(f"‚Äö√π√• /saude - chave 'mensagem' ausente na resposta JSON.")
                    self.assertIn("mensagem", response_json)

                if "version" in response_json:
                    colored_print_success(f"‚Äö√∫√ñ Teste /saude OK: Chave 'version' encontrada na resposta JSON.")
                else:
                    colored_print_warning(f"‚Äö√∂‚Ä†√î‚àè√® /saude - chave 'version' ausente na resposta JSON (pode ser opcional).")

            except json.JSONDecodeError:
                colored_print_failure(f"‚Äö√π√• /saude - Resposta n‚àö¬£o ‚àö¬© um JSON v‚àö¬∞lido: {resposta.text}")
                self.fail("Resposta /saude n‚àö¬£o ‚àö¬© um JSON v‚àö¬∞lido")
        else:
            colored_print_failure(f"‚Äö√π√• Rota /saude falhou, status code: {resposta.status_code}")


    def test_rota_somar_numeros_positivos(self):
        numeros = [1, 2, 3, 4, 5]
        soma_esperada = sum(numeros)
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="resultado", expected_result_value=soma_esperada, test_name="/somar n‚àö‚à´meros positivos")

    def test_rota_calcular_media_numeros_positivos(self):
        numeros = [1, 2, 3, 4, 5]
        media_esperada = sum(numeros) / len(numeros)
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="media", expected_result_value=media_esperada, test_name="/calcular_media n‚àö‚à´meros positivos")

    def test_rota_somar_lista_vazia_erro_422(self):
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": []}, expected_status=422, test_name="/somar lista vazia (erro 422)")

    def test_rota_calcular_media_lista_vazia_retorna_none(self):
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": []}, expected_status=200, expected_result_key="media", expected_result_value=None, test_name="/calcular_media lista vazia (media None)")

    def test_rota_somar_input_nao_lista_erro_422(self):
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": "string"}, expected_status=422, test_name="/somar input n‚àö¬£o lista (erro 422)")

    def test_rota_calcular_media_input_nao_lista_erro_422(self):
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": "string"}, expected_status=422, test_name="/calcular_media input n‚àö¬£o lista (erro 422)")

    def test_rota_somar_lista_com_nao_inteiros_erro_422(self):
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": [1, 2, "a", 4]}, expected_status=422, test_name="/somar lista com n‚àö¬£o inteiros (erro 422)")

    def test_rota_calcular_media_lista_com_nao_inteiros_erro_422(self):
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": [1, 2, "a", 4]}, expected_status=422, test_name="/calcular_media lista com n‚àö¬£o inteiros (erro 422)")

    def test_rota_somar_lista_com_none_erro_422(self):
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": [1, 2, None, 4]}, expected_status=422, test_name="/somar lista com None (erro 422)")

    def test_rota_calcular_media_lista_com_none_erro_422(self):
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": [1, 2, None, 4]}, expected_status=422, test_name="/calcular_media lista com None (erro 422)")

    def test_rota_somar_lista_com_float_como_string_erro_422(self):
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": [1, 2, "2.5", 4]}, expected_status=422, test_name="/somar lista float string (erro 422)")

    def test_rota_calcular_media_lista_com_float_como_string_erro_422(self):
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": [1, 2, "2.5", 4]}, expected_status=422, test_name="/calcular_media lista float string (erro 422)")

    def test_rota_somar_lista_com_string_int_ok(self):
        numeros = [1, 2, "3", 4]
        soma_esperada = sum([1, 2, 3, 4])
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="resultado", expected_result_value=soma_esperada, test_name="/somar lista com string int (OK)")

    def test_rota_calcular_media_lista_com_string_int_ok(self):
        numeros = [1, 2, "3", 4]
        media_esperada = sum([1, 2, 3, 4]) / len([1, 2, 3, 4])
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="media", expected_result_value=media_esperada, test_name="/calcular_media lista string int (OK)")

    def test_rota_somar_lista_com_float_int_string_ok(self):
        numeros = [1, 2.0, "3", 4]
        soma_esperada = sum([1, 2, 3, 4])
        self._testar_rota_post("/somar", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="resultado", expected_result_value=soma_esperada, test_name="/somar lista float int string (OK)")

    def test_rota_calcular_media_lista_com_float_int_string_ok(self):
        numeros = [1, 2.0, "3", 4]
        media_esperada = sum([1, 2, 3, 4]) / len([1, 2, 3, 4])
        self._testar_rota_post("/calcular_media", self.headers_admin, {"numeros": numeros}, expected_status=200, expected_result_key="media", expected_result_value=media_esperada, test_name="/calcular_media lista float int string (OK)")


if __name__ == "__main__":
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ApiTests))

    runner = unittest.TextTestRunner(verbosity=2)
    test_results = runner.run(suite)
üìÑ Arquivo: .\tests\api_main_tester_v2.py.py
  Tamanho: 0.01 MB (8.51 KB, 8719 bytes)
  N√∫mero de Linhas: 168

  C√≥digo Fonte:
import requests
import json
import os
import unittest
import colorama
from colorama import Fore, Back, Style

colorama.init(autoreset=True)

API_BASE_URL = os.environ.get("API_TEST_URL", "https://localhost:8882")
VERIFY_SSL_CERT = os.environ.get("API_VERIFY_SSL", False) == 'True'

ADMIN_TOKEN = None

def obter_token_admin():
    global ADMIN_TOKEN
    token_url = f"{API_BASE_URL}/token_admin"
    credenciais = {"username": "admin", "password": "admin"}
    try:
        resposta = requests.post(token_url, json=credenciais, verify=VERIFY_SSL_CERT)
        resposta.raise_for_status()
        ADMIN_TOKEN = resposta.json().get("access_token")
        colored_print_success("Ô£ø√º√Æ√´ Token ADMIN obtido.")
        return ADMIN_TOKEN
    except requests.exceptions.RequestException as e:
        print(Fore.RED + Style.BRIGHT + f"Ô£ø√º√Æ‚Ä¢ Erro ao obter token ADMIN: {e}" + Style.RESET_ALL)
        return None

def colored_print_success(msg):
    print(Fore.GREEN + Style.BRIGHT + "‚Äö√∫√ñ " + msg + Style.RESET_ALL)

def colored_print_failure(msg):
    print(Fore.RED + Style.BRIGHT + "‚Äö√π√• " + msg + Style.RESET_ALL)

def colored_print_info(msg):
    print(Fore.CYAN + Style.BRIGHT + "‚Äö√ëœÄ√î‚àè√®  " + msg + Style.RESET_ALL)

def colored_print_warning(msg):
    print(Fore.YELLOW + Style.BRIGHT + "‚Äö√∂‚Ä†√î‚àè√®  " + msg + Style.RESET_ALL)

def colored_print_header(msg):
    print(Back.BLUE + Fore.WHITE + Style.BRIGHT + " " + msg + " " + Style.RESET_ALL)


class TestApiProd(unittest.TestCase):

    def setUp(self):
        global ADMIN_TOKEN
        if not ADMIN_TOKEN:
            ADMIN_TOKEN = obter_token_admin()
            if not ADMIN_TOKEN:
                self.skipTest("Token ADMIN n‚àö¬£o obtido, pulando testes.")
        self.admin_token = ADMIN_TOKEN
        self.headers_admin = {"Authorization": f"Bearer {self.admin_token}"}

    def _testar_rota_post(self, url_path, data, expected_status=200, expected_result_key=None, expected_result_value=None, test_name="Rota POST"):
        url = f"{API_BASE_URL}{url_path}"
        colored_print_info(f"‚Äö√ª¬∞√î‚àè√®  Testando rota: {url_path} - Dados: {data}")

        resposta = requests.post(url, headers=self.headers_admin, json=data, verify=VERIFY_SSL_CERT)

        if resposta.status_code != expected_status:
            colored_print_failure(f"‚Äö√π√• {test_name} FALHOU: Status code incorreto. Esperado: {expected_status}, Obtido: {resposta.status_code}. Response Body: {resposta.text}")
            self.assertEqual(resposta.status_code, expected_status)
            return

        if expected_status < 400 and expected_result_key:
            try:
                response_json = resposta.json()
                actual_value = response_json.get(expected_result_key)
                self.assertEqual(actual_value, expected_result_value, f"Valor incorreto para chave '{expected_result_key}'. Esperado: {expected_result_value}, Obtido: {actual_value}")
                colored_print_success(f"‚Äö√∫√ñ {test_name} OK: Valor de '{expected_result_key}' validado. ({expected_result_value})")
            except json.JSONDecodeError:
                self.fail(f"‚Äö√π√• {test_name} FALHOU: Erro ao decodificar JSON. Response text: {resposta.text}")


    def test_soma_inteiros_validos(self):
        self._testar_rota_post("/somar", {"numeros": [1, 2, 3, 4]}, expected_status=200, expected_result_key="resultado", expected_result_value=10, test_name="soma_inteiros_validos")

    def test_soma_strings_numericas_validas(self):
        self._testar_rota_post("/somar", {"numeros": ["5", "10", "15"]}, expected_status=200, expected_result_key="resultado", expected_result_value=30, test_name="soma_strings_numericas_validas")

    def test_soma_lista_vazia_erro(self):
        self._testar_rota_post("/somar", {"numeros": []}, expected_status=422, test_name="soma_lista_vazia_erro")

    def test_soma_tipo_invalido_string_erro(self):
        self._testar_rota_post("/somar", {"numeros": "nao_eh_lista"}, expected_status=422, test_name="soma_tipo_invalido_string_erro")

    def test_soma_lista_com_string_erro(self):
        self._testar_rota_post("/somar", {"numeros": [1, 2, "a", 4]}, expected_status=422, test_name="soma_lista_com_string_erro")

    def test_soma_lista_com_float_sem_perda(self):
        self._testar_rota_post("/somar", {"numeros": [1, 2, 3.0, 4]}, expected_status=200, expected_result_key="resultado", expected_result_value=10, test_name="soma_lista_com_float_sem_perda")

    def test_soma_lista_com_float_com_perda_erro(self):
        self._testar_rota_post("/somar", {"numeros": [1, 2, 3.5, 4]}, expected_status=422, test_name="soma_lista_com_float_com_perda_erro")

    def test_soma_lista_com_none_erro(self):
        self._testar_rota_post("/somar", {"numeros": [1, 2, None, 4]}, expected_status=422, test_name="soma_lista_com_none_erro")


    def test_media_inteiros_validos(self):
        self._testar_rota_post("/calcular_media", {"numeros": [1, 2, 3, 4]}, expected_status=200, expected_result_key="media", expected_result_value=2.5, test_name="media_inteiros_validos")

    def test_media_strings_numericas_validas(self):
        self._testar_rota_post("/calcular_media", {"numeros": ["5", "10", "15"]}, expected_status=200, expected_result_key="media", expected_result_value=10.0, test_name="media_strings_numericas_validas")

    def test_media_lista_vazia_ok(self):
        self._testar_rota_post("/calcular_media", {"numeros": []}, expected_status=200, expected_result_key="media", expected_result_value=None, test_name="media_lista_vazia_ok")

    def test_media_tipo_invalido_string_erro(self):
        self._testar_rota_post("/calcular_media", {"numeros": "nao_eh_lista"}, expected_status=422, test_name="media_tipo_invalido_string_erro")

    def test_media_lista_com_string_erro(self):
        self._testar_rota_post("/calcular_media", {"numeros": [1, 2, "a", 4]}, expected_status=422, test_name="media_lista_com_string_erro")

    def test_media_lista_com_float_sem_perda(self):
        self._testar_rota_post("/calcular_media", {"numeros": [1, 2, 3.0, 4]}, expected_status=200, expected_result_key="media", expected_result_value=2.5, test_name="media_lista_com_float_sem_perda")

    def test_media_lista_com_float_com_perda_erro(self):
        self._testar_rota_post("/calcular_media", {"numeros": [1, 2, 3.5, 4]}, expected_status=422, test_name="media_lista_com_float_com_perda_erro")

    def test_media_lista_com_none_erro(self):
        self._testar_rota_post("/calcular_media", {"numeros": [1, 2, None, 4]}, expected_status=422, test_name="media_lista_com_none_erro")

    def test_media_divisao_por_zero(self):
        self._testar_rota_post("/calcular_media", {"numeros": [0, 0, 0]}, expected_status=200, expected_result_key="media", expected_result_value=0.0, test_name="media_divisao_por_zero")


if __name__ == "__main__":
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TestApiProd))

    runner = unittest.TextTestRunner(verbosity=2)
    test_results = runner.run(suite)

    total_tests = suite.countTestCases()
    passed_tests = total_tests - (len(test_results.errors) + len(test_results.failures))
    failed_tests = total_tests - passed_tests

    if total_tests > 0:
        percentage_passed = (passed_tests / total_tests) * 100
        percentage_failed = (failed_tests / total_tests) * 100
    else:
        percentage_passed = 0
        percentage_failed = 0

    print(Fore.BLUE + Style.BRIGHT + "\nÔ£ø√º√¨√§ Resumo dos Testes:" + Style.RESET_ALL)
    if percentage_passed == 100:
        print(Fore.GREEN + Style.BRIGHT + "Ô£ø√º√®√ú Todos os testes PASSARAM! Ô£ø√º√©√¢" + Style.RESET_ALL)
    elif percentage_failed == 100:
        print(Fore.RED + Style.BRIGHT + "Ô£ø√º√∂¬Æ Todos os testes FALHARAM! Ô£ø√º√≠√Æ" + Style.RESET_ALL)
    else:
        print(Fore.GREEN + Style.BRIGHT + f"‚Äö√∫√ñ Passou: {percentage_passed:.2f}% ({passed_tests}/{total_tests})" + Style.RESET_ALL)
        print(Fore.RED + Style.BRIGHT + f"‚Äö√π√• Reprovou: {percentage_failed:.2f}% ({failed_tests}/{total_tests})" + Style.RESET_ALL)

    if percentage_passed >= 70:
        status_emoji = "Ô£ø√º√≤√©Ô£ø√º√´√ß"
        status_color = Fore.GREEN
    elif percentage_passed >= 50:
        status_emoji = "Ô£ø√º√¥√á"
        status_color = Fore.YELLOW
    else:
        status_emoji = "Ô£ø√º√≤√ªÔ£ø√º√≠√Æ"
        status_color = Fore.RED

    print(status_color + Style.BRIGHT + f"\n‚Äö√∫¬Æ Status Geral: {status_emoji} {percentage_passed:.2f}% de Aprova‚àö√ü‚àö¬£o! {status_emoji}" + Style.RESET_ALL)
    print(Fore.BLUE + Style.BRIGHT + "\nÔ£ø√º√®√Ö Testes Simplificados e Diretos da API de Produ‚àö√ü‚àö¬£o Conclu‚àö‚â†dos." + Style.RESET_ALL)
üìÑ Arquivo: .\tests\test_lib_calc_numbers.py
  Tamanho: 0.01 MB (5.54 KB, 5673 bytes)
  N√∫mero de Linhas: 117

  C√≥digo Fonte:
import sys
import os
import json
import datetime
import pytest
from bibliotecas.calc_numbers import Numbers

DIRETORIO_LOGS_TESTE = "test_logs"
if not os.path.exists(DIRETORIO_LOGS_TESTE):
    os.makedirs(DIRETORIO_LOGS_TESTE)

def obter_proximo_nome_arquivo_log():
    contador_logs = 1
    while True:
        nome_arquivo_log = os.path.join(DIRETORIO_LOGS_TESTE, f"log_teste_{contador_logs}.json")
        if not os.path.exists(nome_arquivo_log):
            return nome_arquivo_log
        contador_logs += 1

def salvar_log_teste(dados_log):
    nome_arquivo_log = obter_proximo_nome_arquivo_log()
    with open(nome_arquivo_log, 'w', encoding='utf-8') as arquivo:
        json.dump(dados_log, arquivo, indent=4, ensure_ascii=False)
    print(f"Resultados dos testes salvos em: {nome_arquivo_log}")


def executar_testes():
    calculadora = Numbers()
    resultados_teste = []

    casos_teste_soma = [
        {"nome": "soma_inteiros_validos", "entrada": [1, 2, 3, 4], "saida_esperada": 10, "espera_excecao": None},
        {"nome": "soma_strings_numericas_validas", "entrada": ["5", "10", "15"], "saida_esperada": 30, "espera_excecao": None},
        {"nome": "soma_lista_vazia", "entrada": [], "saida_esperada": None, "espera_excecao": ValueError},
        {"nome": "soma_tipo_invalido_string", "entrada": "nao_eh_lista", "saida_esperada": None, "espera_excecao": TypeError},
        {"nome": "soma_lista_com_string", "entrada": [1, 2, "a", 4], "saida_esperada": None, "espera_excecao": ValueError},
        {"nome": "soma_lista_com_float_sem_perda", "entrada": [1, 2, 3.0, 4], "saida_esperada": 10, "espera_excecao": None},
        {"nome": "soma_lista_com_float_com_perda", "entrada": [1, 2, 3.5, 4], "saida_esperada": None, "espera_excecao": ValueError},
        {"nome": "soma_lista_com_none", "entrada": [1, 2, None, 4], "saida_esperada": None, "espera_excecao": ValueError},
    ]

    for caso in casos_teste_soma:
        resultado = executar_caso_teste(calculadora.sum_numbers, caso)
        resultados_teste.append(resultado)

    casos_teste_media = [
        {"nome": "media_inteiros_validos", "entrada": [1, 2, 3, 4], "saida_esperada": 2.5, "espera_excecao": None},
        {"nome": "media_strings_numericas_validas", "entrada": ["5", "10", "15"], "saida_esperada": 10.0, "espera_excecao": None},
        {"nome": "media_lista_vazia", "entrada": [], "saida_esperada": None, "espera_excecao": None},
        {"nome": "media_tipo_invalido_string", "entrada": "nao_eh_lista", "saida_esperada": None, "espera_excecao": TypeError},
        {"nome": "media_lista_com_string", "entrada": [1, 2, "a", 4], "saida_esperada": None, "espera_excecao": ValueError},
        {"nome": "media_lista_com_float_sem_perda", "entrada": [1, 2, 3.0, 4], "saida_esperada": 2.5, "espera_excecao": None},
        {"nome": "media_lista_com_float_com_perda", "entrada": [1, 2, 3.5, 4], "saida_esperada": None, "espera_excecao": ValueError},
        {"nome": "media_lista_com_none", "entrada": [1, 2, None, 4], "saida_esperada": None, "espera_excecao": ValueError},
        {"nome": "media_divisao_por_zero", "entrada": [0, 0, 0], "saida_esperada": 0.0, "espera_excecao": None},
    ]

    for caso in casos_teste_media:
        resultado = executar_caso_teste(calculadora.calculate_average, caso)
        resultados_teste.append(resultado)

    dados_log = {"timestamp_execucao_teste": datetime.datetime.now().isoformat(), "resultados_teste": resultados_teste}
    salvar_log_teste(dados_log)


def executar_caso_teste(funcao_testar, caso_teste):
    nome_teste = caso_teste["nome"]
    dados_entrada = caso_teste["entrada"]
    saida_esperada = caso_teste["saida_esperada"]
    excecao_esperada = caso_teste["espera_excecao"]

    entrada_log = {"nome_teste": nome_teste, "entrada": dados_entrada, "saida_esperada": saida_esperada, "excecao_esperada": excecao_esperada.__name__ if excecao_esperada else None}

    try:
        if excecao_esperada:
            with pytest.raises(excecao_esperada) as info_excecao:
                funcao_testar(dados_entrada)
            saida_real = None
            status_teste = "PASSOU"
            entrada_log["excecao_real"] = info_excecao.type.__name__
            entrada_log["mensagem_excecao"] = str(info_excecao.value)

        else:
            saida_real = funcao_testar(dados_entrada)
            if saida_esperada is None:
                if saida_real is None:
                    status_teste = "PASSOU"
                else:
                    status_teste = "FALHOU"
                    entrada_log["saida_real"] = saida_real
            elif isinstance(saida_esperada, float):
                if pytest.approx(saida_real) == saida_esperada:
                    status_teste = "PASSOU"
                else:
                    status_teste = "FALHOU"
                    entrada_log["saida_real"] = saida_real
            else:
                if saida_real == saida_esperada:
                    status_teste = "PASSOU"
                else:
                    status_teste = "FALHOU"
                    entrada_log["saida_real"] = saida_real

    except Exception as erro:
        status_teste = "ERRO"
        entrada_log["status_teste"] = status_teste
        entrada_log["mensagem_erro"] = str(erro)
        saida_real = None

    entrada_log["status_teste"] = status_teste
    return entrada_log


if __name__ == "__main__":
    print("Iniciando testes da biblioteca calc_numbers...")
    executar_testes()
    print("Testes da biblioteca calc_numbers conclu‚àö‚â†dos e resultados salvos em test_logs/")
üìÑ Arquivo: .\test_logs\log_teste_1.json
  Tamanho: 0.01 MB (6.64 KB, 6799 bytes)
  N√∫mero de Linhas: 204
  Conte√∫do n√£o textual ou extens√£o n√£o suportada para visualiza√ß√£o do c√≥digo fonte.
